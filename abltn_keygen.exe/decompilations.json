{"FUN_00401000": "\nLRESULT FUN_00401000(HWND param_1,UINT param_2,WPARAM param_3,int param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  LRESULT LVar3;\n  HDC hDC;\n  HBRUSH hbr;\n  HFONT h;\n  HGDIOBJ h_00;\n  int iVar4;\n  tagPAINTSTRUCT local_60;\n  tagRECT local_20;\n  LOGBRUSH local_10;\n  \n  iVar1 = DAT_00424734;\n  if (param_2 == 0xf) {\n    hDC = BeginPaint(param_1,&local_60);\n    local_10.lbStyle = 0;\n    GetClientRect(param_1,&local_20);\n    iVar2 = local_20.bottom;\n    local_20.bottom = 0;\n    for (; local_20.top < iVar2; local_20.top = local_20.top + 4) {\n      iVar4 = iVar2 - local_20.top;\n      local_10.lbColor =\n           (uint)CONCAT11((char)((int)((uint)*(byte *)(iVar1 + 0x52) * iVar4 +\n                                      (uint)*(byte *)(iVar1 + 0x56) * local_20.top) / iVar2),\n                          (char)((int)((uint)*(byte *)(iVar1 + 0x51) * iVar4 +\n                                      (uint)*(byte *)(iVar1 + 0x55) * local_20.top) / iVar2)) << 8 |\n           (int)((uint)*(byte *)(iVar1 + 0x50) * iVar4 +\n                (uint)*(byte *)(iVar1 + 0x54) * local_20.top) / iVar2 & 0xffU;\n      hbr = CreateBrushIndirect(&local_10);\n      local_20.bottom = local_20.bottom + 4;\n      FillRect(hDC,&local_20,hbr);\n      DeleteObject(hbr);\n    }\n    if (*(int *)(iVar1 + 0x58) != -1) {\n      h = CreateFontIndirectA(*(LOGFONTA **)(iVar1 + 0x34));\n      if (h != (HFONT)0x0) {\n        local_20.left = 0x10;\n        local_20.top = 8;\n        SetBkMode(hDC,1);\n        SetTextColor(hDC,*(COLORREF *)(iVar1 + 0x58));\n        h_00 = SelectObject(hDC,h);\n        DrawTextA(hDC,&DAT_00423f20,-1,&local_20,0x820);\n        SelectObject(hDC,h_00);\n        DeleteObject(h);\n      }\n    }\n    EndPaint(param_1,&local_60);\n    LVar3 = 0;\n  }\n  else {\n    if (param_2 == 0x46) {\n      *(uint *)(param_4 + 0x18) = *(uint *)(param_4 + 0x18) | 0x10;\n      *(undefined4 *)(param_4 + 4) = DAT_00424728;\n    }\n    LVar3 = DefWindowProcA(param_1,param_2,param_3,param_4);\n  }\n  return LVar3;\n}\n\n", "FUN_0040117d": "\nvoid FUN_0040117d(int param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint *puVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  \n  uVar1 = *(uint *)(param_1 * 0x418 + 8 + DAT_00424768);\n  if ((uVar1 & 2) != 0) {\n    uVar4 = param_1 + 1;\n    if (uVar4 < DAT_0042476c) {\n      puVar3 = (uint *)(uVar4 * 0x418 + 8 + DAT_00424768);\n      iVar5 = 0;\n      do {\n        uVar2 = *puVar3;\n        if ((uVar2 & 2) == 0) {\n          if ((uVar2 & 4) == 0) {\n            iVar6 = iVar5;\n            if ((uVar2 & 0x10) == 0) {\n              *puVar3 = (uVar2 ^ uVar1) & 1 ^ uVar2;\n            }\n          }\n          else {\n            iVar6 = iVar5 + -1;\n            if (iVar5 == 0) {\n              return;\n            }\n          }\n        }\n        else {\n          iVar6 = iVar5 + 1;\n        }\n        uVar4 = uVar4 + 1;\n        puVar3 = puVar3 + 0x106;\n        iVar5 = iVar6;\n      } while (uVar4 < DAT_0042476c);\n    }\n  }\n  return;\n}\n\n", "FUN_004011ef": "\nuint FUN_004011ef(uint param_1,int param_2)\n\n{\n  uint *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  int local_c;\n  int local_8;\n  \n  iVar2 = DAT_00424768;\n  iVar5 = param_1 * 0x418 + DAT_00424768;\n  local_8 = 0;\n  local_c = 0;\n  if (((*(uint *)(iVar5 + 8) & 2) != 0) && (param_2 != 0)) {\n    param_1 = param_1 + 1;\n    *(uint *)(iVar5 + 8) = *(uint *)(iVar5 + 8) & 0xffffffbe;\n  }\n  if (param_1 < DAT_0042476c) {\n    do {\n      puVar1 = (uint *)(param_1 * 0x418 + 8 + iVar2);\n      uVar3 = param_1 + 1;\n      uVar4 = *puVar1;\n      if ((uVar4 & 2) != 0) {\n        uVar3 = FUN_004011ef(param_1,1);\n        uVar4 = *puVar1;\n      }\n      if ((uVar4 & 4) != 0) {\n        if (local_8 == 0) {\n          return uVar3;\n        }\n        if (local_c != 0) {\n          *(uint *)(iVar5 + 8) = *(uint *)(iVar5 + 8) | 0x40;\n          return uVar3;\n        }\n        *(uint *)(iVar5 + 8) = *(uint *)(iVar5 + 8) & 0xffffff7f | 1;\n        return uVar3;\n      }\n      if ((uVar4 & 0x40) != 0) {\n        local_8 = local_8 + 1;\n      }\n      if ((uVar4 & 1) == 0) {\n        local_c = local_c + 1;\n      }\n      else {\n        local_8 = local_8 + 1;\n      }\n      param_1 = uVar3;\n    } while (uVar3 < DAT_0042476c);\n  }\n  return 0;\n}\n\n", "FUN_00401299": "\nvoid FUN_00401299(uint param_1)\n\n{\n  uint uVar1;\n  uint *puVar2;\n  uint uVar3;\n  \n  uVar3 = 0;\n  if ((param_1 < 0x20) && (DAT_0042476c != 0)) {\n    puVar2 = (uint *)(DAT_00424768 + 8);\n    do {\n      uVar1 = *puVar2;\n      if ((uVar1 & 6) == 0) {\n        if ((puVar2[-1] & 1 << ((byte)param_1 & 0x1f)) == 0) {\n          uVar1 = uVar1 & 0xfffffffe;\n        }\n        else {\n          uVar1 = uVar1 | 1;\n        }\n        *puVar2 = uVar1;\n      }\n      uVar3 = uVar3 + 1;\n      puVar2 = puVar2 + 0x106;\n    } while (uVar3 < DAT_0042476c);\n  }\n  return;\n}\n\n", "FUN_004012e2": "\nuint FUN_004012e2(int param_1)\n\n{\n  uint uVar1;\n  uint *puVar2;\n  bool bVar3;\n  int *local_c;\n  uint local_8;\n  \n  local_8 = 0;\n  local_c = (int *)(DAT_00424734 + 0x94);\n  do {\n    uVar1 = 0;\n    if (*local_c != 0) {\n      bVar3 = DAT_0042476c == 0;\n      if (DAT_0042476c != 0) {\n        puVar2 = (uint *)(DAT_00424768 + 8);\n        do {\n          if (((*puVar2 & 6) == 0) &&\n             (((param_1 == 0 || (*(int *)(param_1 + uVar1 * 4) != 0)) &&\n              ((puVar2[-1] & 1 << ((byte)local_8 & 0x1f)) != (*puVar2 & 1) << ((byte)local_8 & 0x1f)\n              )))) break;\n          uVar1 = uVar1 + 1;\n          puVar2 = puVar2 + 0x106;\n        } while (uVar1 < DAT_0042476c);\n        bVar3 = uVar1 == DAT_0042476c;\n      }\n      if (bVar3) {\n        return local_8;\n      }\n    }\n    local_8 = local_8 + 1;\n    local_c = local_c + 1;\n    if (0x1f < local_8) {\n      return local_8;\n    }\n  } while( true );\n}\n\n", "FUN_0040136d": "\nvoid FUN_0040136d(int param_1)\n\n{\n  if (param_1 < 0) {\n    FUN_0040604b(&DAT_00425000 + (param_1 + 1) * -0x400);\n  }\n  return;\n}\n\n", "FUN_00401389": "\nundefined4 FUN_00401389(int param_1,HWND param_2)\n\n{\n  HWND__ HVar1;\n  HWND pHVar2;\n  int iVar3;\n  int iVar4;\n  WPARAM wParam;\n  LPARAM lParam;\n  \n  while ((-1 < param_1 && (HVar1 = (HWND__)(param_1 * 0x1c + DAT_00424770), *(int *)HVar1 != 1))) {\n    pHVar2 = FUN_00401434(HVar1);\n    if (pHVar2 == (HWND)0x7fffffff) {\n      return 0x7fffffff;\n    }\n    iVar3 = FUN_0040136d((int)pHVar2);\n    if (iVar3 == 0) {\n      iVar4 = 1;\n      iVar3 = param_1 + 1;\n    }\n    else {\n      iVar3 = iVar3 + -1;\n      iVar4 = iVar3 - param_1;\n    }\n    param_1 = iVar3;\n    if (param_2 != (HWND)0x0) {\n      DAT_00423f0c = DAT_00423f0c + iVar4;\n      lParam = 0;\n      wParam = MulDiv(DAT_00423f0c,30000,DAT_00423ef4);\n      SendMessageA(param_2,0x402,wParam,lParam);\n    }\n  }\n  return 0;\n}\n\n", "FUN_0040140b": "\nvoid FUN_0040140b(int param_1)\n\n{\n  FUN_00401389(*(int *)(DAT_00424734 + 0x6c + param_1 * 4),(HWND)0x0);\n  return;\n}\n\n", "FUN_00401423": "\nvoid FUN_00401423(int param_1)\n\n{\n  FUN_004051fb(param_1,&DAT_0040a800);\n  return;\n}\n\n", "FUN_00402aa9": "\nvoid __cdecl FUN_00402aa9(int param_1)\n\n{\n  byte *pbVar1;\n  \n  pbVar1 = (byte *)FUN_004060f6((byte *)0x0,*(int *)(DAT_0040b83c + param_1 * 4));\n  FUN_0040604b(pbVar1);\n  return;\n}\n\n", "FUN_00402acb": "\nbyte * FUN_00402acb(uint param_1)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  \n  uVar1 = param_1;\n  if ((int)param_1 < 0) {\n    uVar1 = -param_1;\n  }\n  pbVar2 = (byte *)FUN_004060f6(&DAT_0040a400 + ((int)uVar1 >> 4) * 0x400,\n                                *(int *)(DAT_0040b83c + (uVar1 & 0xf) * 4));\n  if ((int)param_1 < 0) {\n    FUN_0040633e(pbVar2);\n  }\n  return pbVar2;\n}\n\n", "FUN_00402b0b": "\nuint FUN_00402b0b(HKEY param_1)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  uint uVar3;\n  LSTATUS LVar4;\n  HKEY *ppHVar5;\n  \n  ppHVar5 = &param_1;\n  uVar1 = (uint)param_1 | 0x100020;\n  pbVar2 = FUN_00402acb(0x22);\n  uVar3 = FUN_00402b43(*(int *)(DAT_0040b83c + 4));\n  LVar4 = FUN_00405f5a(uVar3,(LPCSTR)pbVar2,uVar1,ppHVar5);\n  return ~-(uint)(LVar4 != 0) & (uint)param_1;\n}\n\n", "FUN_00402b43": "\nint FUN_00402b43(int param_1)\n\n{\n  if (-1 < param_1) {\n    param_1 = DAT_004247c4 + -0x7fffffff + param_1;\n  }\n  return param_1;\n}\n\n", "FUN_00402b5b": "\nuint FUN_00402b5b(int param_1,LPCSTR param_2,HKEY param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  LSTATUS LVar3;\n  HKEY *ppHVar4;\n  \n  ppHVar4 = &param_3;\n  uVar1 = (uint)param_3 | 0x100020;\n  uVar2 = FUN_00402b43(param_1);\n  LVar3 = FUN_00405f88(uVar2,param_2,uVar1,ppHVar4);\n  return ~-(uint)(LVar3 != 0) & (uint)param_3;\n}\n\n", "FUN_00402b89": "\nLSTATUS FUN_00402b89(int param_1,LPCSTR param_2,uint param_3)\n\n{\n  LSTATUS LVar1;\n  uint uVar2;\n  HKEY pHVar3;\n  uint *puVar4;\n  \n  if (*param_2 == '\\0') {\n    LVar1 = 0x3eb;\n  }\n  else {\n    param_3 = param_3 | 0x100020;\n    puVar4 = &param_3;\n    uVar2 = FUN_00402b43(param_1);\n    pHVar3 = (HKEY)FUN_00405edf(uVar2,puVar4);\n    if (pHVar3 == (HKEY)0x0) {\n      LVar1 = 6;\n    }\n    else {\n      LVar1 = FUN_00402bcd(pHVar3,param_2,param_3);\n    }\n  }\n  return LVar1;\n}\n\n", "FUN_00402bcd": "\nLSTATUS FUN_00402bcd(HKEY param_1,LPCSTR param_2,uint param_3)\n\n{\n  LSTATUS LVar1;\n  FARPROC pFVar2;\n  CHAR local_110 [264];\n  HKEY local_8;\n  \n  LVar1 = FUN_00405f5a((uint)param_1,param_2,CONCAT31((int3)((param_3 & 0x300) >> 8),8),&local_8);\n  if (LVar1 == 0) {\n    do {\n      LVar1 = RegEnumKeyA(local_8,0,local_110,0x105);\n      if (LVar1 != 0) break;\n      if ((param_3 & 1) != 0) {\n        RegCloseKey(local_8);\n        return 0x3eb;\n      }\n      LVar1 = FUN_00402bcd(local_8,local_110,param_3);\n    } while (LVar1 == 0);\n    RegCloseKey(local_8);\n    pFVar2 = FUN_0040646c(3);\n    if (pFVar2 == (FARPROC)0x0) {\n      LVar1 = RegDeleteKeyA(param_1,param_2);\n    }\n    else {\n      LVar1 = (*pFVar2)(param_1,param_2,param_3 & 0x300,0);\n    }\n  }\n  return LVar1;\n}\n\n", "FUN_00402c7c": "\nundefined4 FUN_00402c7c(HWND param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  char *pcVar2;\n  CHAR local_44 [64];\n  \n  if (param_2 == 0x110) {\n    SetTimer(param_1,1,0xfa,(TIMERPROC)0x0);\n    param_2 = 0x113;\n  }\n  if (param_2 == 0x113) {\n    uVar1 = FUN_00402cf8();\n    pcVar2 = s_unpacking_data___d___0040a03c;\n    if (DAT_00424734 == 0) {\n      pcVar2 = s_verifying_installer___d___0040a020;\n    }\n    wsprintfA(local_44,pcVar2,uVar1);\n    SetWindowTextA(param_1,local_44);\n    SetDlgItemTextA(param_1,0x406,local_44);\n  }\n  return 0;\n}\n\n", "FUN_00402cf8": "\nvoid FUN_00402cf8(void)\n\n{\n  int nNumber;\n  \n  nNumber = DAT_004178d8;\n  if (DAT_004178e8 <= DAT_004178d8) {\n    nNumber = DAT_004178e8;\n  }\n  MulDiv(nNumber,100,DAT_004178e8);\n  return;\n}\n\n", "FUN_00402d14": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid __cdecl FUN_00402d14(int param_1)\n\n{\n  DWORD DVar1;\n  undefined4 uVar2;\n  CHAR local_44 [64];\n  \n  if (param_1 == 0) {\n    if (DAT_004178e4 == (HWND)0x0) {\n      DVar1 = GetTickCount();\n      if (_DAT_00424730 < DVar1) {\n        if (DAT_00424728 == 0) {\n          DAT_004178e4 = CreateDialogParamA(DAT_00424720,(LPCSTR)0x6f,(HWND)0x0,FUN_00402c7c,0);\n          ShowWindow(DAT_004178e4,5);\n        }\n        else if (((byte)DAT_004247f4 & 1) != 0) {\n          uVar2 = FUN_00402cf8();\n          wsprintfA(local_44,s______d___0040a054,uVar2);\n          FUN_004051fb(0,local_44);\n        }\n      }\n    }\n    else {\n      FUN_004064a8(0);\n    }\n  }\n  else {\n    if (DAT_004178e4 != (HWND)0x0) {\n      DestroyWindow(DAT_004178e4);\n    }\n    DAT_004178e4 = (HWND)0x0;\n  }\n  return;\n}\n\n", "FUN_00402db3": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nchar * FUN_00402db3(uint param_1)\n\n{\n  DWORD DVar1;\n  HANDLE hFile;\n  LPCSTR pCVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  undefined4 *puVar6;\n  int *piVar7;\n  uint uVar8;\n  CHAR local_12c [260];\n  uint local_28;\n  int local_24;\n  int local_20;\n  int local_1c;\n  int local_18;\n  SIZE_T local_14;\n  int local_10;\n  int local_c;\n  uint local_8;\n  \n  local_8 = 0;\n  local_c = 0;\n  DVar1 = GetTickCount();\n  _DAT_00424730 = DVar1 + 1000;\n  GetModuleFileNameA((HMODULE)0x0,&DAT_0042bc00,0x400);\n  hFile = (HANDLE)FUN_00405c6d(&DAT_0042bc00,0x80000000,3);\n  if (hFile == (HANDLE)0xffffffff) {\n    DAT_0040a018 = hFile;\n    return s_Error_launching_installer_0040a174;\n  }\n  DAT_0040a018 = hFile;\n  FUN_004060d4(&DAT_0042ac00,&DAT_0042bc00);\n  pCVar2 = FUN_00405ab3(&DAT_0042ac00);\n  FUN_004060d4(&DAT_0042c000,pCVar2);\n  uVar3 = GetFileSize(hFile,(LPDWORD)0x0);\n  DAT_004178e8 = uVar3;\n  for (; 0 < (int)uVar3; uVar3 = uVar3 - uVar8) {\n    uVar4 = (-(uint)(DAT_00424738 != 0) & 0x7e00) + 0x200;\n    uVar8 = uVar3;\n    if ((int)uVar4 <= (int)uVar3) {\n      uVar8 = uVar4;\n    }\n    iVar5 = FUN_004032ca(&DAT_004178f0,uVar8);\n    if (iVar5 == 0) {\n      FUN_00402d14(1);\n      goto LAB_0040300a;\n    }\n    if (DAT_00424738 == 0) {\n      FUN_00405c28((undefined *)&local_28,(int)&DAT_004178f0,0x1c);\n      if (((((local_28 & 0xfffffff0) == 0) && (local_24 == -0x21524111)) && (local_18 == 0x74736e49)\n          ) && ((local_1c == 0x74666f73 && (local_20 == 0x6c6c754e)))) {\n        param_1 = param_1 | local_28;\n        _DAT_004247e0 = _DAT_004247e0 | param_1 & 2;\n        DAT_00424738 = DAT_004178d8;\n        if ((int)uVar3 < local_10) goto LAB_0040300a;\n        if (((param_1 & 8) == 0) && ((param_1 & 4) != 0)) break;\n        local_c = local_c + 1;\n        uVar3 = local_10 - 4;\n        if (uVar3 < uVar8) {\n          uVar8 = uVar3;\n        }\n      }\n    }\n    else if ((param_1 & 2) == 0) {\n      FUN_00402d14(0);\n    }\n    if ((int)uVar3 < (int)DAT_004178e8) {\n      local_8 = FUN_00406523(local_8,&DAT_004178f0,uVar8);\n    }\n    DAT_004178d8 = DAT_004178d8 + uVar8;\n  }\n  FUN_00402d14(1);\n  if (DAT_00424738 != 0) {\n    if (local_c != 0) {\n      FUN_004032e0(DAT_004178d8);\n      iVar5 = FUN_004032ca(&param_1,4);\n      if ((iVar5 == 0) || (local_8 != param_1)) goto LAB_0040300a;\n    }\n    puVar6 = (undefined4 *)GlobalAlloc(0x40,local_14);\n    FUN_00406591((int)&DAT_0040b850);\n    FUN_00405c9c(local_12c,&DAT_0042b400);\n    DAT_0040a01c = CreateFileA(local_12c,0xc0000000,0,(LPSECURITY_ATTRIBUTES)0x0,2,0x4000100,\n                               (HANDLE)0x0);\n    if (DAT_0040a01c == (HANDLE)0xffffffff) {\n      return s_Error_writing_temporary_file__Ma_0040a130;\n    }\n    DAT_004178ec = FUN_004032e0(DAT_00424738 + 0x1c);\n    DAT_004178e0 = (DAT_004178ec - (~local_28 & 4)) + -0x1c + local_10;\n    DVar1 = FUN_00403059(0xffffffff,(HANDLE)0x0,puVar6,local_14);\n    if (DVar1 == local_14) {\n      DAT_0042473c = *puVar6;\n      if ((local_28 & 1) != 0) {\n        _DAT_00424740 = _DAT_00424740 + 1;\n      }\n      piVar7 = puVar6 + 0x11;\n      iVar5 = 8;\n      DAT_00424734 = puVar6;\n      do {\n        piVar7 = piVar7 + -2;\n        *piVar7 = *piVar7 + (int)puVar6;\n        iVar5 = iVar5 + -1;\n      } while (iVar5 != 0);\n      puVar6[0xf] = DAT_004178dc;\n      FUN_00405c28(&DAT_00424760,(int)(puVar6 + 1),0x40);\n      return (char *)0x0;\n    }\n  }\nLAB_0040300a:\n  return s_Installer_integrity_check_has_fa_0040a060;\n}\n\n", "FUN_00403059": "\nint FUN_00403059(DWORD param_1,HANDLE param_2,LPVOID param_3,DWORD param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  DWORD nNumberOfBytesToRead;\n  BOOL BVar3;\n  DWORD local_8;\n  \n  if (-1 < (int)param_1) {\n    DAT_004178dc = param_1 + DAT_00424798;\n    SetFilePointer(DAT_0040a01c,DAT_004178dc,(PLONG)0x0,0);\n  }\n  iVar1 = FUN_00403161(4);\n  if (iVar1 < 0) {\n    return iVar1;\n  }\n  iVar1 = FUN_00405ce5(DAT_0040a01c,&param_1,4);\n  if (iVar1 != 0) {\n    DAT_004178dc = DAT_004178dc + 4;\n    iVar1 = FUN_00403161(param_1);\n    if (iVar1 < 0) {\n      return iVar1;\n    }\n    if (param_3 == (LPVOID)0x0) {\n      while( true ) {\n        if ((int)param_1 < 1) {\n          return iVar1;\n        }\n        local_8 = param_1;\n        if (0x3fff < (int)param_1) {\n          local_8 = 0x4000;\n        }\n        iVar2 = FUN_00405ce5(DAT_0040a01c,&DAT_004138d8,local_8);\n        if (iVar2 == 0) break;\n        iVar2 = FUN_00405d14(param_2,&DAT_004138d8,local_8);\n        if (iVar2 == 0) {\n          return -2;\n        }\n        param_1 = param_1 - local_8;\n        DAT_004178dc = DAT_004178dc + local_8;\n        iVar1 = iVar1 + local_8;\n      }\n    }\n    else {\n      nNumberOfBytesToRead = param_1;\n      if ((int)param_4 <= (int)param_1) {\n        nNumberOfBytesToRead = param_4;\n      }\n      BVar3 = ReadFile(DAT_0040a01c,param_3,nNumberOfBytesToRead,&local_8,(LPOVERLAPPED)0x0);\n      if (BVar3 != 0) {\n        DAT_004178dc = DAT_004178dc + local_8;\n        return local_8;\n      }\n    }\n  }\n  return -3;\n}\n\n", "FUN_00403161": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 FUN_00403161(int param_1)\n\n{\n  DWORD DVar1;\n  int iVar2;\n  undefined *puVar3;\n  \n  iVar2 = (DAT_004178dc - DAT_0040b848) + param_1;\n  DVar1 = GetTickCount();\n  _DAT_00424730 = DVar1 + 500;\n  if (0 < iVar2) {\n    FUN_004032e0(DAT_004178ec);\n    SetFilePointer(DAT_0040a01c,DAT_0040b848,(PLONG)0x0,0);\n    DAT_004178d8 = 0;\n    DAT_004178e8 = iVar2;\n    do {\n      DVar1 = 0x4000;\n      if (DAT_004178e0 - DAT_004178ec < 0x4001) {\n        DVar1 = DAT_004178e0 - DAT_004178ec;\n      }\n      iVar2 = FUN_004032ca(&DAT_004138d8,DVar1);\n      if (iVar2 == 0) {\n        return 0xffffffff;\n      }\n      DAT_004178ec = DAT_004178ec + DVar1;\n      _DAT_0040b868 = &DAT_004138d8;\n      _DAT_0040b86c = DVar1;\n      do {\n        if ((DAT_00424734 != 0) && (_DAT_004247e0 == 0)) {\n          DAT_004178d8 = DAT_0040b848 + ((DAT_004178e8 - DAT_004178dc) - param_1);\n          FUN_00402d14(0);\n        }\n        DAT_0040b870 = &DAT_0040b8d8;\n        _DAT_0040b874 = 0x8000;\n        iVar2 = FUN_004065b1((uint *)&DAT_0040b850);\n        if (iVar2 < 0) {\n          return 0xfffffffd;\n        }\n        puVar3 = DAT_0040b870 + -0x40b8d8;\n        if (puVar3 == (undefined *)0x0) {\n          if (_DAT_0040b86c != 0) {\n            return 0xfffffffd;\n          }\n          if (DVar1 == 0) {\n            return 0xfffffffd;\n          }\n          break;\n        }\n        iVar2 = FUN_00405d14(DAT_0040a01c,&DAT_0040b8d8,(DWORD)puVar3);\n        if (iVar2 == 0) {\n          return 0xfffffffe;\n        }\n        DAT_0040b848 = DAT_0040b848 + (int)puVar3;\n      } while (_DAT_0040b86c != 0);\n    } while (0 < (DAT_004178dc - DAT_0040b848) + param_1);\n    SetFilePointer(DAT_0040a01c,DAT_004178dc,(PLONG)0x0,0);\n  }\n  FUN_00402d14(1);\n  return 0;\n}\n\n", "FUN_004032ca": "\nvoid FUN_004032ca(LPVOID param_1,DWORD param_2)\n\n{\n  FUN_00405ce5(DAT_0040a018,param_1,param_2);\n  return;\n}\n\n", "FUN_004032e0": "\nvoid FUN_004032e0(LONG param_1)\n\n{\n  SetFilePointer(DAT_0040a018,param_1,(PLONG)0x0,0);\n  return;\n}\n\n", "FUN_004032f7": "\nvoid FUN_004032f7(void)\n\n{\n  int iVar1;\n  \n  FUN_0040633e(&DAT_0042b400);\n  iVar1 = FUN_00405ad9(&DAT_0042b400);\n  if (iVar1 == 0) {\n    return;\n  }\n  FUN_00405a6c(&DAT_0042b400);\n  FUN_0040573e(&DAT_0042b400);\n  FUN_00405c9c(&DAT_0042b000,&DAT_0042b400);\n  return;\n}\n\n", "entry": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid entry(void)\n\n{\n  char cVar1;\n  bool bVar2;\n  DWORD DVar3;\n  FARPROC pFVar4;\n  int iVar5;\n  LPSTR pCVar6;\n  LPCSTR lpsz;\n  uint *puVar7;\n  uint *puVar8;\n  undefined3 extraout_var;\n  int iVar9;\n  HANDLE pvVar10;\n  BOOL BVar11;\n  char *pcVar12;\n  uint **TokenHandle;\n  char *local_184;\n  char local_180;\n  UINT local_17c;\n  uint *puStack376;\n  uint local_174;\n  _TOKEN_PRIVILEGES _Stack368;\n  SHFILEINFOA SStack352;\n  \n  local_17c = 0;\n  local_184 = s_Error_writing_temporary_file__Ma_0040a130;\n  local_174 = 0;\n  local_180 = ' ';\n  SetErrorMode(0x8001);\n  DVar3 = GetVersion();\n  DAT_0042472c = DVar3 & 0xbfffffff;\n  if (((short)DAT_0042472c != 6) && (pFVar4 = FUN_0040646c(0), pFVar4 != (FARPROC)0x0)) {\n    (*pFVar4)(0xc00);\n  }\n  pcVar12 = \"UXTHEME\";\n  do {\n    FUN_004063fe(pcVar12);\n    iVar5 = lstrlenA(pcVar12);\n    pcVar12 = pcVar12 + iVar5 + 1;\n  } while (*pcVar12 != '\\0');\n  FUN_0040646c(10);\n  DAT_00424724 = FUN_0040646c(8);\n  pFVar4 = FUN_0040646c(6);\n  if ((pFVar4 != (FARPROC)0x0) && (iVar5 = (*pFVar4)(0x1e), iVar5 != 0)) {\n    DAT_0042472c = DAT_0042472c | 0x40000000;\n  }\n  Ordinal_17();\n  _DAT_004247f8 = OleInitialize((LPVOID)0x0);\n  SHGetFileInfoA(&DAT_0041fcf0,0,&SStack352,0x160,0);\n  FUN_004060d4(&DAT_00423f20,s_NSIS_Error_0040a1ec);\n  pCVar6 = GetCommandLineA();\n  FUN_004060d4(&DAT_0042a000,pCVar6);\n  DAT_00424720 = 0x400000;\n  pcVar12 = &DAT_0042a000;\n  if (DAT_0042a000 == '\\\"') {\n    local_180 = '\\\"';\n    pcVar12 = &DAT_0042a001;\n  }\n  lpsz = (LPCSTR)FUN_00405a97(pcVar12,local_180);\n  puVar7 = (uint *)CharNextA(lpsz);\n  puStack376 = puVar7;\n  while (cVar1 = *(char *)puVar7, cVar1 != '\\0') {\n    while (cVar1 == ' ') {\n      puVar7 = (uint *)((int)puVar7 + 1);\n      cVar1 = *(char *)puVar7;\n    }\n    local_180 = ' ';\n    if (*(char *)puVar7 == '\\\"') {\n      puVar7 = (uint *)((int)puVar7 + 1);\n      local_180 = '\\\"';\n    }\n    puVar8 = puVar7;\n    if (*(char *)puVar7 == '/') {\n      puVar8 = (uint *)((int)puVar7 + 1);\n      if ((*(char *)puVar8 == 'S') &&\n         ((*(char *)((int)puVar7 + 2) == ' ' || (*(char *)((int)puVar7 + 2) == '\\0')))) {\n        _DAT_004247e0 = 1;\n      }\n      if ((*puVar8 ==\n           ((((int)DAT_0040a1e7 << 8 | (int)DAT_0040a1e6) << 8 | (int)DAT_0040a1e5) << 8 |\n           (int)DAT_0040a1e4)) &&\n         ((*(char *)((int)puVar7 + 5) == ' ' || (*(char *)((int)puVar7 + 5) == '\\0')))) {\n        local_174 = local_174 | 4;\n      }\n      if (*(uint *)((int)puVar7 + -1) ==\n          ((((int)DAT_0040a1df << 8 | (int)DAT_0040a1de) << 8 | (int)DAT_0040a1dd) << 8 |\n          (int)DAT_0040a1dc)) {\n        *(char *)((int)puVar7 + -1) = '\\0';\n        FUN_004060d4(&DAT_0042a400,(LPCSTR)((int)puVar7 + 3));\n        break;\n      }\n    }\n    puVar7 = (uint *)FUN_00405a97((LPCSTR)puVar8,local_180);\n    if (*(char *)puVar7 == '\\\"') {\n      puVar7 = (uint *)((int)puVar7 + 1);\n    }\n  }\n  GetTempPathA(0x400,&DAT_0042b400);\n  iVar5 = FUN_004032f7();\n  if (iVar5 == 0) {\n    GetWindowsDirectoryA(&DAT_0042b400,0x3fb);\n    lstrcatA(&DAT_0042b400,s__Temp_0040a1d4);\n    iVar5 = FUN_004032f7();\n    if (iVar5 == 0) {\n      GetTempPathA(0x3fc,&DAT_0042b400);\n      lstrcatA(&DAT_0042b400,&DAT_0040a1d0);\n      SetEnvironmentVariableA(&DAT_0040a1c8,&DAT_0042b400);\n      SetEnvironmentVariableA(&DAT_0040a1c4,&DAT_0042b400);\n      iVar5 = FUN_004032f7();\n      if (iVar5 == 0) goto LAB_00403642;\n    }\n  }\n  DeleteFileA(&DAT_0042b000);\n  local_184 = FUN_00402db3(local_174);\n  if (local_184 != (char *)0x0) goto LAB_00403642;\n  if (_DAT_00424740 != 0) {\n    puVar7 = (uint *)FUN_00405a97(&DAT_0042a000,'\\0');\n    if ((uint *)0x429fff < puVar7) {\n      do {\n        if (*puVar7 ==\n            ((((int)DAT_0040a1bf << 8 | (int)DAT_0040a1be) << 8 | (int)DAT_0040a1bd) << 8 |\n            (int)DAT_0040a1bc)) break;\n        puVar7 = (uint *)((int)puVar7 + -1);\n      } while ((uint *)0x429fff < puVar7);\n    }\n    local_184 = s_Error_launching_installer_0040a174;\n    if (puVar7 < &DAT_0042a000) {\n      iVar5 = FUN_0040575b();\n      lstrcatA(&DAT_0042b400,&DAT_0040a1b4);\n      if (iVar5 != 0) {\n        lstrcatA(&DAT_0042b400,&DAT_0040a1b0);\n      }\n      lstrcatA(&DAT_0042b400,&DAT_0040a1a8);\n      iVar9 = lstrcmpiA(&DAT_0042b400,&DAT_0042ac00);\n      if (iVar9 != 0) {\n        if (iVar5 == 0) {\n          FUN_0040573e(&DAT_0042b400);\n        }\n        else {\n          FUN_004056c1(&DAT_0042b400);\n        }\n        SetCurrentDirectoryA(&DAT_0042b400);\n        if (DAT_0042a400 == '\\0') {\n          FUN_004060d4(&DAT_0042a400,&DAT_0042ac00);\n        }\n        FUN_004060d4(&DAT_00425000,(LPCSTR)puStack376);\n        iVar5 = 0x1a;\n        _DAT_00425400 = (ushort)DAT_0040a1a5 << 8 | (short)DAT_0040a1a4;\n        do {\n          FUN_004060f6(&DAT_0041f8f0,*(int *)(DAT_00424734 + 0x120));\n          DeleteFileA(&DAT_0041f8f0);\n          if ((local_184 != (char *)0x0) &&\n             (BVar11 = CopyFileA(&DAT_0042bc00,&DAT_0041f8f0,1), BVar11 != 0)) {\n            FUN_00405eb3(&DAT_0041f8f0,(LPCSTR)0x0);\n            FUN_004060f6(&DAT_0041f8f0,*(int *)(DAT_00424734 + 0x124));\n            pvVar10 = FUN_00405773(&DAT_0041f8f0);\n            if (pvVar10 != (HANDLE)0x0) {\n              CloseHandle(pvVar10);\n              local_184 = (char *)0x0;\n            }\n          }\n          DAT_00425400 = DAT_00425400 + 1;\n          _DAT_00425400 = _DAT_00425400 & 0xff00 | (ushort)DAT_00425400;\n          iVar5 = iVar5 + -1;\n        } while (iVar5 != 0);\n        FUN_00405eb3(&DAT_0042b400,(LPCSTR)0x0);\n      }\n      goto LAB_00403642;\n    }\n    *(undefined *)puVar7 = 0;\n    puVar7 = puVar7 + 1;\n    bVar2 = FUN_00405b5a((LPCSTR)puVar7);\n    if (CONCAT31(extraout_var,bVar2) == 0) goto LAB_00403642;\n    FUN_004060d4(&DAT_0042a400,(LPCSTR)puVar7);\n    FUN_004060d4(&DAT_0042a800,(LPCSTR)puVar7);\n    local_184 = (char *)0x0;\n  }\n  DAT_004247ec = -1;\n  local_17c = FUN_00403902();\nLAB_00403642:\n  FUN_00403810();\n  OleUninitialize();\n  if (local_184 != (char *)0x0) {\n    FUN_004057f0(local_184,0x200010);\n                    /* WARNING: Subroutine does not return */\n    ExitProcess(2);\n  }\n  if (_DAT_004247d4 != 0) {\n    TokenHandle = &puStack376;\n    DVar3 = 0x28;\n    pvVar10 = GetCurrentProcess();\n    BVar11 = OpenProcessToken(pvVar10,DVar3,TokenHandle);\n    if (BVar11 != 0) {\n      LookupPrivilegeValueA\n                ((LPCSTR)0x0,s_SeShutdownPrivilege_0040a190,&_Stack368.Privileges[0].Luid);\n      _Stack368.PrivilegeCount = 1;\n      _Stack368.Privileges[0].Attributes = 2;\n      AdjustTokenPrivileges(puStack376,0,&_Stack368,0,(PTOKEN_PRIVILEGES)0x0,(PDWORD)0x0);\n    }\n    pFVar4 = FUN_0040646c(4);\n    if (((pFVar4 != (FARPROC)0x0) && (iVar5 = (*pFVar4)(0,0,0,0x25,0x80040002), iVar5 == 0)) ||\n       (BVar11 = ExitWindowsEx(2,0x80040002), BVar11 == 0)) {\n      FUN_0040140b(9);\n    }\n  }\n  if (DAT_004247ec != -1) {\n    local_17c = DAT_004247ec;\n  }\n                    /* WARNING: Subroutine does not return */\n  ExitProcess(local_17c);\n}\n\n", "FUN_00403810": "\nvoid FUN_00403810(void)\n\n{\n  if (DAT_0040a018 != (HANDLE)0xffffffff) {\n    CloseHandle(DAT_0040a018);\n    DAT_0040a018 = (HANDLE)0xffffffff;\n  }\n  if (DAT_0040a01c != (HANDLE)0xffffffff) {\n    CloseHandle(DAT_0040a01c);\n    DAT_0040a01c = (HANDLE)0xffffffff;\n  }\n  FUN_0040386d();\n  FUN_0040589c(&DAT_0042b800,7);\n  return;\n}\n\n", "FUN_00403852": "\nvoid FUN_00403852(undefined4 param_1)\n\n{\n  undefined4 *puVar1;\n  \n  for (puVar1 = DAT_0041fcf4; puVar1 != (undefined4 *)0x0; puVar1 = (undefined4 *)*puVar1) {\n    (*(code *)puVar1[1])(param_1);\n  }\n  return;\n}\n\n", "FUN_0040386d": "\nvoid FUN_0040386d(void)\n\n{\n  int *piVar1;\n  int *hMem;\n  \n  hMem = DAT_0041fcf4;\n  FUN_00403852(0);\n  if (hMem != (int *)0x0) {\n    do {\n      piVar1 = (int *)*hMem;\n      FreeLibrary((HMODULE)hMem[2]);\n      GlobalFree(hMem);\n      hMem = piVar1;\n    } while (piVar1 != (int *)0x0);\n  }\n  DAT_0041fcf4 = (int *)0x0;\n  return;\n}\n\n", "FUN_004038a2": "\nundefined4 FUN_004038a2(int param_1)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = DAT_0041fcf4;\n  while( true ) {\n    if (puVar1 == (undefined4 *)0x0) {\n      return 1;\n    }\n    if (puVar1[2] == param_1) break;\n    puVar1 = (undefined4 *)*puVar1;\n  }\n  return 0;\n}\n\n", "FUN_004038c0": "\nundefined4 FUN_004038c0(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 *puVar3;\n  \n  iVar1 = FUN_004038a2(param_1);\n  if (iVar1 == 0) {\n    uVar2 = 1;\n  }\n  else {\n    puVar3 = (undefined4 *)GlobalAlloc(0x40,0xc);\n    if (puVar3 == (undefined4 *)0x0) {\n      uVar2 = 0xffffffff;\n    }\n    else {\n      puVar3[2] = param_1;\n      puVar3[1] = param_2;\n      *puVar3 = DAT_0041fcf4;\n      uVar2 = 0;\n      DAT_0041fcf4 = puVar3;\n    }\n  }\n  return uVar2;\n}\n\n", "FUN_00403902": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nINT_PTR FUN_00403902(void)\n\n{\n  bool bVar1;\n  ATOM AVar2;\n  FARPROC pFVar3;\n  uint uVar4;\n  undefined3 extraout_var;\n  undefined *puVar5;\n  int iVar6;\n  DWORD DVar7;\n  LPCSTR pCVar8;\n  undefined3 extraout_var_00;\n  int iVar9;\n  INT_PTR IVar10;\n  BOOL BVar11;\n  char *lpString;\n  int iStack16;\n  int iStack12;\n  int iStack8;\n  int iStack4;\n  \n  iVar9 = DAT_00424734;\n  pFVar3 = FUN_0040646c(2);\n  if (pFVar3 == (FARPROC)0x0) {\n    DAT_0042b000 = 0x30;\n    DAT_0042b001 = 0x78;\n    DAT_0042b002 = 0;\n    FUN_00405fbb(0x80000001,\"Control Panel\\\\Desktop\\\\ResourceLocale\",(LPCSTR)0x0,\n                 (LPBYTE)&DAT_00420d30,(HKEY)0x0);\n    if (DAT_00420d30 == '\\0') {\n      FUN_00405fbb(0x80000003,\".DEFAULT\\\\Control Panel\\\\International\",\"Locale\",\n                   (LPBYTE)&DAT_00420d30,(HKEY)0x0);\n    }\n    lstrcatA(&DAT_0042b000,&DAT_00420d30);\n  }\n  else {\n    uVar4 = (*pFVar3)();\n    FUN_00406032(&DAT_0042b000,uVar4 & 0xffff);\n  }\n  FUN_00403bc7();\n  _DAT_004247c0 = DAT_0042473c & 0x20;\n  _DAT_004247dc = 0x10000;\n  bVar1 = FUN_00405b5a(&DAT_0042a400);\n  if ((CONCAT31(extraout_var,bVar1) == 0) && (*(int *)(iVar9 + 0x48) != 0)) {\n    lpString = &DAT_004236c0;\n    FUN_00405fbb(*(uint *)(iVar9 + 0x44),(LPCSTR)(*(int *)(iVar9 + 0x48) + DAT_00424778),\n                 (LPCSTR)(*(int *)(iVar9 + 0x4c) + DAT_00424778),(LPBYTE)&DAT_004236c0,(HKEY)0x0);\n    if (DAT_004236c0 != '\\0') {\n      if (DAT_004236c0 == '\\\"') {\n        lpString = &DAT_004236c1;\n        puVar5 = (undefined *)FUN_00405a97(&DAT_004236c1,'\\\"');\n        *puVar5 = 0;\n      }\n      iVar6 = lstrlenA(lpString);\n      if (((lpString < lpString + iVar6 + -4) &&\n          (iVar6 = lstrcmpiA(lpString + iVar6 + -4,&DAT_0040a214), iVar6 == 0)) &&\n         ((DVar7 = GetFileAttributesA(lpString), DVar7 == 0xffffffff || ((DVar7 & 0x10) == 0)))) {\n        FUN_00405ab3(lpString);\n      }\n      pCVar8 = FUN_00405a6c(lpString);\n      FUN_004060d4(&DAT_0042a400,pCVar8);\n    }\n  }\n  bVar1 = FUN_00405b5a(&DAT_0042a400);\n  if (CONCAT31(extraout_var_00,bVar1) == 0) {\n    FUN_004060f6(&DAT_0042a400,*(int *)(iVar9 + 0x118));\n  }\n  DAT_00423f08 = LoadImageA(DAT_00424720,(LPCSTR)0x67,1,0,0,0x8040);\n  if (*(int *)(iVar9 + 0x50) == -1) {\nLAB_00403aee:\n    iVar9 = FUN_0040140b(0);\n    if (iVar9 == 0) {\n      FUN_00403bc7();\n      if (_DAT_004247e0 == 0) {\n        ShowWindow(DAT_00420d10,5);\n        iVar9 = FUN_004063fe(\"RichEd20\");\n        if (iVar9 == 0) {\n          FUN_004063fe(\"RichEd32\");\n        }\n        BVar11 = GetClassInfoA((HINSTANCE)0x0,\"RichEdit20A\",(LPWNDCLASSA)&DAT_00423ec0);\n        if (BVar11 == 0) {\n          GetClassInfoA((HINSTANCE)0x0,\"RichEdit\",(LPWNDCLASSA)&DAT_00423ec0);\n          _DAT_00423ee4 = \"RichEdit20A\";\n          RegisterClassA((WNDCLASSA *)&DAT_00423ec0);\n        }\n        IVar10 = DialogBoxParamA(DAT_00424720,(LPCSTR)(DAT_00423f00 + 0x69U & 0xffff),(HWND)0x0,\n                                 (DLGPROC)&LAB_00403c9f,0);\n        FUN_0040140b(5);\n        FUN_00403852(1);\n        return IVar10;\n      }\n      iVar9 = FUN_004052cd((HWND)0x0);\n      if (iVar9 == 0) {\n        FUN_0040140b(1);\n        goto LAB_00403bbd;\n      }\n      if (_DAT_00423eec == 0) {\n        FUN_0040140b(2);\n      }\n    }\n    IVar10 = 2;\n  }\n  else {\n    _DAT_00423ec4 = FUN_00401000;\n    _DAT_00423ed0 = DAT_00424720;\n    _DAT_00423ee4 = &DAT_0040a210;\n    _DAT_00423ed4 = DAT_00423f08;\n    AVar2 = RegisterClassA((WNDCLASSA *)&DAT_00423ec0);\n    if (AVar2 != 0) {\n      SystemParametersInfoA(0x30,0,&iStack16,0);\n      DAT_00420d10 = CreateWindowExA(0x80,&DAT_0040a210,(LPCSTR)0x0,0x80000000,iStack16,iStack12,\n                                     iStack8 - iStack16,iStack4 - iStack12,(HWND)0x0,(HMENU)0x0,\n                                     DAT_00424720,(LPVOID)0x0);\n      goto LAB_00403aee;\n    }\nLAB_00403bbd:\n    IVar10 = 0;\n  }\n  return IVar10;\n}\n\n", "FUN_00403bc7": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00403bc7(void)\n\n{\n  int iVar1;\n  ushort *puVar2;\n  ushort uVar3;\n  int iVar4;\n  int *piVar5;\n  \n  uVar3 = 0xffff;\n  iVar1 = FUN_0040604b(&DAT_0042b000);\n  do {\n    if (DAT_00424784 != 0) {\n      puVar2 = (ushort *)(*(int *)(DAT_00424734 + 100) * DAT_00424784 + _DAT_00424780);\n      iVar4 = DAT_00424784;\n      do {\n        puVar2 = (ushort *)((int)puVar2 - *(int *)(DAT_00424734 + 100));\n        iVar4 = iVar4 + -1;\n        if (((*puVar2 ^ (ushort)iVar1) & uVar3) == 0) {\n          DAT_00423f00 = *(undefined4 *)(puVar2 + 1);\n          _DAT_004247e8 = *(undefined4 *)(puVar2 + 3);\n          DAT_00423efc = puVar2 + 5;\n          if (DAT_00423efc != (ushort *)0x0) {\n            FUN_00406032(&DAT_0042b000,(uint)*puVar2);\n            FUN_00403c80();\n            piVar5 = DAT_00424768;\n            for (iVar1 = DAT_0042476c; iVar1 != 0; iVar1 = iVar1 + -1) {\n              if (*piVar5 != 0) {\n                FUN_004060f6((byte *)(piVar5 + 6),*piVar5);\n              }\n              piVar5 = piVar5 + 0x106;\n            }\n            return;\n          }\n          break;\n        }\n      } while (iVar4 != 0);\n    }\n    if (uVar3 == 0xffff) {\n      uVar3 = 0x3ff;\n    }\n    else {\n      uVar3 = 0;\n    }\n  } while( true );\n}\n\n", "FUN_00403c80": "\nundefined * FUN_00403c80(void)\n\n{\n  FUN_004060f6(&DAT_00423f20,-2);\n  SetWindowTextA(DAT_00420d10,&DAT_00423f20);\n  return &DAT_00423f20;\n}\n\n", "FUN_0040414c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0040414c(WPARAM param_1)\n\n{\n  if (param_1 == 0x78) {\n    _DAT_00423eec = _DAT_00423eec + 1;\n  }\n  SendMessageA(DAT_00424728,0x408,param_1,0);\n  return;\n}\n\n", "FUN_00404173": "\nvoid FUN_00404173(HWND param_1,int param_2,int param_3)\n\n{\n  LPCSTR lpString;\n  \n  lpString = (LPCSTR)FUN_004060f6((byte *)0x0,param_3);\n  SetDlgItemTextA(param_1,param_2 + 1000,lpString);\n  return;\n}\n\n", "FUN_00404195": "\nvoid FUN_00404195(BOOL param_1)\n\n{\n  EnableWindow(DAT_00420d2c,param_1);\n  return;\n}\n\n", "FUN_004041a8": "\nvoid FUN_004041a8(WPARAM param_1)\n\n{\n  SendMessageA(DAT_00424728,0x28,param_1,1);\n  return;\n}\n\n", "FUN_004041bf": "\nvoid FUN_004041bf(UINT param_1)\n\n{\n  if (DAT_00423ef8 != (HWND)0x0) {\n    SendMessageA(DAT_00423ef8,param_1,0,0);\n  }\n  return;\n}\n\n", "FUN_004041da": "\nCOLORREF FUN_004041da(int param_1,HDC param_2,HWND param_3)\n\n{\n  COLORREF *pCVar1;\n  COLORREF color;\n  HBRUSH pHVar2;\n  LOGBRUSH local_10;\n  \n  if ((((param_1 - 0x133U < 6) &&\n       (pCVar1 = (COLORREF *)GetWindowLongA(param_3,-0x15), pCVar1 != (COLORREF *)0x0)) &&\n      (pCVar1[2] < 2)) && ((pCVar1[4] < 3 && ((pCVar1[5] & 0xffffffe0) == 0)))) {\n    color = *pCVar1;\n    if ((pCVar1[5] & 2) != 0) {\n      color = GetSysColor(color);\n    }\n    if ((*(byte *)(pCVar1 + 5) & 1) != 0) {\n      SetTextColor(param_2,color);\n    }\n    SetBkMode(param_2,pCVar1[4]);\n    local_10.lbColor = pCVar1[1];\n    if ((*(byte *)(pCVar1 + 5) & 8) != 0) {\n      local_10.lbColor = GetSysColor(local_10.lbColor);\n    }\n    if ((*(byte *)(pCVar1 + 5) & 4) != 0) {\n      SetBkColor(param_2,local_10.lbColor);\n    }\n    if ((*(byte *)(pCVar1 + 5) & 0x10) != 0) {\n      local_10.lbStyle = pCVar1[2];\n      if ((HGDIOBJ)pCVar1[3] != (HGDIOBJ)0x0) {\n        DeleteObject((HGDIOBJ)pCVar1[3]);\n      }\n      pHVar2 = CreateBrushIndirect(&local_10);\n      pCVar1[3] = (COLORREF)pHVar2;\n    }\n    return pCVar1[3];\n  }\n  return 0;\n}\n\n", "FUN_004042a9": "\nundefined4 FUN_004042a9(int param_1,LPSTR param_2,int param_3,int *param_4)\n\n{\n  int iVar1;\n  \n  lstrcpynA(param_2,(LPCSTR)(DAT_0041fcfc + param_1),param_3);\n  iVar1 = lstrlenA(param_2);\n  *param_4 = iVar1;\n  DAT_0041fcfc = DAT_0041fcfc + iVar1;\n  return 0;\n}\n\n", "FUN_004042de": "\nCOLORREF FUN_004042de(HWND param_1,int param_2,HDC param_3,HWND param_4)\n\n{\n  uint *puVar1;\n  char cVar2;\n  HWND pHVar3;\n  DWORD lParam;\n  int iVar4;\n  HCURSOR pHVar5;\n  COLORREF CVar6;\n  uint uVar7;\n  HWND__ lpString;\n  UINT Msg;\n  WPARAM wParam;\n  LPARAM lParam_00;\n  HWND__ local_10;\n  int local_c;\n  code *local_8;\n  \n  if (param_2 == 0x110) {\n    iVar4 = param_4[0xc].unused;\n    if (iVar4 < 0) {\n      iVar4 = *(int *)(DAT_00423efc - (iVar4 * 4 + 4));\n    }\n    cVar2 = *(char *)(iVar4 + DAT_00424778);\n    local_c = 0;\n    lpString = (HWND__)((char *)(iVar4 + DAT_00424778) + 1);\n    local_8 = FUN_004042a9;\n    uVar7 = (uint)~param_4[5].unused >> 5 & 1 | param_4[5].unused & 1U;\n    local_10 = (int)lpString;\n    FUN_00404173(param_1,0x22,param_4[0xd].unused);\n    FUN_00404173(param_1,0x23,param_4[0xe].unused);\n    CheckDlgButton(param_1,(uVar7 == 0) + 0x40a,1);\n    FUN_00404195(uVar7);\n    pHVar3 = GetDlgItem(param_1,1000);\n    FUN_004041a8((WPARAM)pHVar3);\n    SendMessageA(pHVar3,0x45b,1,0);\n    lParam = *(DWORD *)(DAT_00424734 + 0x68);\n    if ((int)lParam < 0) {\n      lParam = GetSysColor(-lParam);\n    }\n    SendMessageA(pHVar3,0x443,0,lParam);\n    SendMessageA(pHVar3,0x445,0,0x4010000);\n    iVar4 = lstrlenA((LPCSTR)lpString);\n    SendMessageA(pHVar3,0x435,0,iVar4);\n    DAT_0041fcfc = 0;\n    SendMessageA(pHVar3,0x449,(int)cVar2,(LPARAM)&local_10);\n    DAT_0041fcfc = 0;\n    return 0;\n  }\n  if (param_2 == 0x111) {\n    if ((((short)((uint)param_3 >> 0x10) != 0) || (DAT_0041fcfc != 0)) ||\n       (puVar1 = (uint *)(DAT_00420508 + 0x14), (*(byte *)puVar1 & 0x20) == 0)) goto LAB_0040454b;\n    lParam_00 = 0;\n    wParam = 0;\n    Msg = 0xf0;\n    pHVar3 = GetDlgItem(param_1,0x40a);\n    uVar7 = SendMessageA(pHVar3,Msg,wParam,lParam_00);\n    *puVar1 = *puVar1 & 0xfffffffe | uVar7 & 1;\n    FUN_00404195(uVar7 & 1);\n    FUN_0040455e();\n  }\n  if (param_2 == 0x4e) {\n    pHVar3 = GetDlgItem(param_1,1000);\n    if ((param_4[2].unused == 0x70b) && (param_4[3].unused == 0x201)) {\n      local_c = param_4[7].unused;\n      local_10 = param_4[6].unused;\n      local_8 = (code *)&DAT_004236c0;\n      if ((uint)(local_c - local_10) < 0x800) {\n        SendMessageA(pHVar3,1099,0,(LPARAM)&local_10);\n        pHVar5 = LoadCursorA((HINSTANCE)0x0,(LPCSTR)0x7f02);\n        SetCursor(pHVar5);\n        FUN_00404582(param_1,(LPCSTR)local_8);\n        pHVar5 = LoadCursorA((HINSTANCE)0x0,(LPCSTR)0x7f00);\n        SetCursor(pHVar5);\n      }\n    }\n    if ((param_4[2].unused == 0x700) && (param_4[3].unused == 0x100)) {\n      if (param_4[4].unused == 0xd) {\n        SendMessageA(DAT_00424728,0x111,1,0);\n      }\n      if (param_4[4].unused == 0x1b) {\n        SendMessageA(DAT_00424728,0x10,0,0);\n      }\n      return 1;\n    }\n  }\n  else if (param_2 == 0x40b) {\n    DAT_0041fcfc = DAT_0041fcfc + 1;\n  }\nLAB_0040454b:\n  CVar6 = FUN_004041da(param_2,param_3,param_4);\n  return CVar6;\n}\n\n", "FUN_0040455e": "\nvoid FUN_0040455e(void)\n\n{\n  HWND hWnd;\n  \n  hWnd = DAT_0041fcf8;\n  if (DAT_004247cc == 0) {\n    hWnd = DAT_00420d2c;\n  }\n  SendMessageA(hWnd,0xf4,1,1);\n  return;\n}\n\n", "FUN_00404582": "\nvoid FUN_00404582(HWND param_1,LPCSTR param_2)\n\n{\n  SHELLEXECUTEINFOA local_40;\n  \n  local_40.lpParameters = (LPCSTR)0x0;\n  local_40.lpDirectory = (LPCSTR)0x0;\n  local_40.hwnd = param_1;\n  local_40.fMask = 0x500;\n  local_40.lpFile = param_2;\n  local_40.nShow = 1;\n  local_40.lpVerb = &DAT_0040a21c;\n  FUN_004057b6(&local_40);\n  return;\n}\n\n", "FUN_004045be": "\nvoid FUN_004045be(HWND param_1,int param_2,HDC param_3,HWND param_4)\n\n{\n  if (param_2 == 0x110) {\n    FUN_00404173(param_1,0x1d,param_4[0xc].unused);\n    SetDlgItemTextA(param_1,1000,&DAT_00425000 + param_4[0xf].unused * 0x400);\n  }\n  FUN_004041da(param_2,param_3,param_4);\n  return;\n}\n\n", "FUN_00404605": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00404605(HWND param_1,int param_2,HDC param_3,HWND param_4)\n\n{\n  bool bVar1;\n  HWND hWnd;\n  int iVar2;\n  char *pcVar3;\n  FARPROC pFVar4;\n  LPITEMIDLIST pv;\n  undefined3 extraout_var;\n  BOOL BVar5;\n  uint uVar6;\n  int iVar7;\n  byte *lpString;\n  LPCITEMIDLIST *ppIVar8;\n  LPCSTR pCVar9;\n  _browseinfoA local_50;\n  uint local_30;\n  uint local_2c;\n  undefined local_28 [4];\n  DWORD local_24;\n  int local_20;\n  undefined local_1c [4];\n  DWORD local_18;\n  DWORD local_14;\n  FARPROC local_10;\n  int local_c;\n  int local_8;\n  \n  local_20 = DAT_00420508;\n  local_c = *(int *)(DAT_00420508 + 0x38);\n  lpString = &DAT_00425000 + *(int *)(DAT_00420508 + 0x3c) * 0x400;\n  if (param_2 == 0x40b) {\n    FUN_004057d4(0x3fb,(LPSTR)lpString);\n    FUN_0040633e(lpString);\n  }\n  if (param_2 == 0x110) {\n    hWnd = GetDlgItem(param_1,0x3fb);\n    iVar2 = FUN_00405ad9(lpString);\n    if ((iVar2 != 0) && (pcVar3 = FUN_00405b05((LPCSTR)lpString), pcVar3 == (char *)0x0)) {\n      FUN_00405a6c((LPCSTR)lpString);\n    }\n    DAT_00423ef8 = param_1;\n    SetWindowTextA(hWnd,(LPCSTR)lpString);\n    FUN_00404173(param_1,1,param_4[0xd].unused);\n    FUN_00404173(param_1,0x14,param_4[0xc].unused);\n    FUN_004041a8((WPARAM)hWnd);\n    pFVar4 = FUN_0040646c(7);\n    if (pFVar4 == (FARPROC)0x0) goto LAB_00404941;\n    (*pFVar4)(hWnd,1);\n  }\n  iVar2 = local_c;\n  if (param_2 == 0x111) {\n    if (((uint)param_3 & 0xffff) == 0x3fb) {\n      if ((short)((uint)param_3 >> 0x10) != 0x300) goto LAB_00404941;\n      param_2 = 0x40f;\n    }\n    if (((uint)param_3 & 0xffff) == 0x3e9) {\n      ppIVar8 = &local_50.pidlRoot;\n      for (iVar7 = 7; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *ppIVar8 = (LPCITEMIDLIST)0x0;\n        ppIVar8 = ppIVar8 + 1;\n      }\n      local_50.hwndOwner = param_1;\n      local_50.pszDisplayName = &DAT_00420d30;\n      local_50.lpfn = FUN_00404956;\n      local_50.lParam = (LPARAM)lpString;\n      local_50.lpszTitle = (LPCSTR)FUN_004060f6(&DAT_00420108,iVar2);\n      local_50.ulFlags = 0x41;\n      pv = SHBrowseForFolderA(&local_50);\n      if (pv == (LPITEMIDLIST)0x0) {\n        param_2 = 0x40f;\n      }\n      else {\n        CoTaskMemFree(pv);\n        FUN_00405a6c((LPCSTR)lpString);\n        if ((*(int *)(DAT_00424734 + 0x11c) != 0) && (lpString == &DAT_0042a400)) {\n          FUN_004060f6((byte *)0x0,*(int *)(DAT_00424734 + 0x11c));\n          iVar2 = lstrcmpiA(&DAT_004236c0,&DAT_00420d30);\n          if (iVar2 != 0) {\n            lstrcatA(&DAT_0042a400,&DAT_004236c0);\n          }\n        }\n        _DAT_00420d20 = _DAT_00420d20 + 1;\n        SetDlgItemTextA(param_1,0x3fb,(LPCSTR)lpString);\n      }\n    }\n  }\n  if ((param_2 == 0x40f) || (param_2 == 0x405)) {\n    local_8 = 0;\n    local_c = 0;\n    FUN_004057d4(0x3fb,(LPSTR)lpString);\n    bVar1 = FUN_00405b5a((LPCSTR)lpString);\n    if (CONCAT31(extraout_var,bVar1) == 0) {\n      local_8 = 1;\n    }\n    FUN_004060d4(&DAT_0041fd00,(LPCSTR)lpString);\n    local_10 = FUN_0040646c(1);\n    if (local_10 != (FARPROC)0x0) {\n      pCVar9 = (LPCSTR)0x0;\n      do {\n        iVar2 = (*local_10)(&DAT_0041fd00,&local_30,local_1c,local_28);\n        if (iVar2 != 0) {\n          local_30 = local_30 >> 10 | local_2c << 0x16;\n          local_2c = local_2c >> 10;\n          local_c = 1;\n          goto LAB_0040489a;\n        }\n        if (pCVar9 != (LPCSTR)0x0) {\n          *pCVar9 = '\\0';\n        }\n        pCVar9 = FUN_00405ab3(&DAT_0041fd00);\n        *pCVar9 = '\\0';\n        pCVar9 = pCVar9 + -1;\n        *pCVar9 = '\\\\';\n      } while (pCVar9 != &DAT_0041fd00);\n    }\n    FUN_004060d4(&DAT_0041fd00,(LPCSTR)lpString);\n    pcVar3 = FUN_00405b05(&DAT_0041fd00);\n    if (pcVar3 != (char *)0x0) {\n      *pcVar3 = '\\0';\n    }\n    BVar5 = GetDiskFreeSpaceA(&DAT_0041fd00,&local_14,&local_18,(LPDWORD)&local_10,&local_24);\n    if (BVar5 != 0) {\n      local_30 = MulDiv(local_14 * local_18,(int)local_10,0x400);\n      local_2c = (int)local_30 >> 0x1f;\n      local_c = 1;\n    }\nLAB_0040489a:\n    uVar6 = FUN_00404a99(5);\n    if (((local_c != 0) && (local_2c == 0)) && (local_30 < uVar6)) {\n      local_8 = 2;\n    }\n    if (*(int *)(DAT_00423efc + 0x10) != 0) {\n      FUN_00404a81(0x3ff,-5,uVar6);\n      if (local_c == 0) {\n        SetDlgItemTextA(param_1,0x400,&DAT_0041fcf0);\n      }\n      else {\n        FUN_004049bc(0x400,-4,local_30,local_2c);\n      }\n    }\n    _DAT_004247e4 = local_8;\n    if (local_8 == 0) {\n      local_8 = FUN_0040140b(7);\n    }\n    if ((*(uint *)(local_20 + 0x14) & 0x400) != 0) {\n      local_8 = 0;\n    }\n    FUN_00404195((uint)(local_8 == 0));\n    if ((local_8 == 0) && (_DAT_00420d20 == 0)) {\n      FUN_0040455e();\n    }\n    _DAT_00420d20 = 0;\n  }\nLAB_00404941:\n  FUN_004041da(param_2,param_3,param_4);\n  return;\n}\n\n", "FUN_00404956": "\nundefined4 FUN_00404956(HWND param_1,int param_2,LPCITEMIDLIST param_3,LPSTR param_4)\n\n{\n  BOOL BVar1;\n  int iVar2;\n  LPARAM lParam;\n  \n  if (param_2 == 1) {\n    FUN_004057d4(0x3fb,param_4);\n    SendMessageA(param_1,0x466,1,(LPARAM)param_4);\n  }\n  if (param_2 == 2) {\n    BVar1 = SHGetPathFromIDListA(param_3,param_4);\n    if ((BVar1 == 0) || (iVar2 = FUN_0040140b(7), iVar2 != 0)) {\n      lParam = 0;\n    }\n    else {\n      lParam = 1;\n    }\n    SendMessageA(param_1,0x465,0,lParam);\n    return 0;\n  }\n  return 0;\n}\n\n", "FUN_004049bc": "\nvoid FUN_004049bc(int param_1,int param_2,uint param_3,int param_4)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  int iVar3;\n  sbyte sVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  char *pcVar8;\n  byte local_44 [32];\n  byte local_24 [32];\n  \n  iVar5 = -0x24;\n  if (param_4 == 0) {\n    sVar4 = 0x14;\n    if (param_3 < 0x100000) {\n      sVar4 = 10;\n      iVar5 = -0x23;\n    }\n    if (param_3 < 0x400) {\n      sVar4 = 0;\n      iVar5 = -0x22;\n    }\n    if (param_3 < 0xffff3333) {\n      param_3 = (1 << sVar4) / 0x14 + param_3;\n    }\n    uVar6 = param_3 >> sVar4;\n    uVar7 = ((param_3 & 0xffffff) * 10 >> sVar4) % 10;\n  }\n  else {\n    uVar6 = param_3 >> 0x14 | param_4 << 0xc;\n    uVar7 = 0;\n  }\n  uVar1 = FUN_004060f6(local_24,-0x21);\n  uVar2 = FUN_004060f6(local_44,iVar5);\n  pcVar8 = s__u__u_s_s_0040a224;\n  iVar5 = FUN_004060f6(&DAT_00420d30,param_2);\n  iVar3 = lstrlenA(&DAT_00420d30);\n  wsprintfA((LPSTR)(iVar5 + iVar3),pcVar8,uVar6,uVar7,uVar2,uVar1);\n  SetDlgItemTextA(DAT_00423ef8,param_1,&DAT_00420d30);\n  return;\n}\n\n", "FUN_00404a81": "\nvoid FUN_00404a81(int param_1,int param_2,uint param_3)\n\n{\n  FUN_004049bc(param_1,param_2,param_3,0);\n  return;\n}\n\n", "FUN_00404a99": "\nint FUN_00404a99(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  \n  iVar1 = 0;\n  iVar2 = DAT_00424768;\n  iVar3 = DAT_0042476c;\n  if (DAT_0042476c != 0) {\n    do {\n      if ((*(byte *)(iVar2 + 8) & 1) != 0) {\n        iVar1 = iVar1 + *(int *)(iVar2 + param_1 * 4);\n      }\n      iVar3 = iVar3 + -1;\n      iVar2 = iVar2 + 0x418;\n    } while (iVar3 != 0);\n  }\n  return iVar1;\n}\n\n", "FUN_00404ac6": "\nundefined4 FUN_00404ac6(HWND param_1,int param_2)\n\n{\n  DWORD DVar1;\n  undefined4 local_3c;\n  LRESULT local_38;\n  undefined4 local_18;\n  tagPOINT local_14;\n  byte local_c;\n  LRESULT local_8;\n  \n  local_38 = SendMessageA(param_1,0x110a,9,0);\n  if (param_2 != 0) {\n    DVar1 = GetMessagePos();\n    local_14.x = (LONG)(short)DVar1;\n    local_14.y = (LONG)(short)(DVar1 >> 0x10);\n    ScreenToClient(param_1,&local_14);\n    SendMessageA(param_1,0x1111,0,(LPARAM)&local_14);\n    local_38 = local_8;\n    if ((local_c & 0x66) == 0) {\n      return 0xffffffff;\n    }\n  }\n  local_3c = 4;\n  SendMessageA(param_1,0x110c,0,(LPARAM)&local_3c);\n  return local_18;\n}\n\n", "FUN_00404b46": "\nvoid FUN_00404b46(int param_1,undefined4 param_2)\n\n{\n  FUN_004060d4(&DAT_00420d30,&DAT_00425000);\n  FUN_00406032(&DAT_00425000,param_2);\n  FUN_0040140b(param_1);\n  FUN_004060d4(&DAT_00425000,&DAT_00420d30);\n  return;\n}\n\n", "FUN_00404b78": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00404b78(HWND param_1,int param_2,HDC param_3,HWND param_4)\n\n{\n  int iVar1;\n  HBITMAP hbmImage;\n  LRESULT LVar2;\n  LPARAM lParam;\n  WPARAM WVar3;\n  LRESULT LVar4;\n  uint uVar5;\n  uint uVar6;\n  HDC pHVar7;\n  HWND pHVar8;\n  int iVar9;\n  uint *puVar10;\n  LPARAM local_54;\n  undefined4 local_50;\n  undefined4 local_4c;\n  undefined4 local_48;\n  uint local_44;\n  uint local_40;\n  uint *local_3c;\n  uint *local_38;\n  undefined4 local_2c;\n  int local_28;\n  HGLOBAL local_20;\n  uint *local_1c;\n  int local_18;\n  int local_14;\n  HWND local_10;\n  HWND local_c;\n  HWND local_8;\n  \n  local_c = GetDlgItem(param_1,0x3f9);\n  local_8 = GetDlgItem(param_1,0x408);\n  local_14 = DAT_00424768;\n  local_18 = DAT_00424734 + 0x94;\n  if (param_2 == 0x110) {\n    local_20 = (HGLOBAL)0x0;\n    local_10 = (HWND)0x2;\n    _DAT_004247a0 = param_1;\n    DAT_00420d28 = GlobalAlloc(0x40,DAT_0042476c << 2);\n    hbmImage = LoadBitmapA(DAT_00424720,(LPCSTR)0x6e);\n    _DAT_00420d1c = 0xffffffff;\n    DAT_00420d24 = SetWindowLongA(local_8,-4,(LONG)FUN_0040516f);\n    DAT_00420d14 = ImageList_Create(0x10,0x10,0x21,6,0);\n    ImageList_AddMasked(DAT_00420d14,hbmImage,0xff00ff);\n    SendMessageA(local_8,0x1109,2,(LPARAM)DAT_00420d14);\n    LVar2 = SendMessageA(local_8,0x111c,0,0);\n    if (LVar2 < 0x10) {\n      SendMessageA(local_8,0x111b,0x10,0);\n    }\n    DeleteObject(hbmImage);\n    iVar9 = 0;\n    do {\n      iVar1 = *(int *)(local_18 + iVar9 * 4);\n      if (iVar1 != 0) {\n        if (iVar9 != 0x20) {\n          local_10 = (HWND)0x0;\n        }\n        lParam = FUN_004060f6((byte *)0x0,iVar1);\n        WVar3 = SendMessageA(local_c,0x143,0,lParam);\n        SendMessageA(local_c,0x151,WVar3,iVar9);\n      }\n      pHVar8 = local_10;\n      iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x21);\n    FUN_00404173(param_1,0x15,param_4[(int)(local_10 + 3)].unused);\n    FUN_00404173(param_1,0x16,param_4[(int)((int)&pHVar8[3].unused + 1)].unused);\n    iVar9 = 0;\n    LVar2 = 0;\n    if (DAT_0042476c < 1) {\nLAB_00404da3:\n      uVar5 = GetWindowLongA(local_8,-0x10);\n      SetWindowLongA(local_8,-0x10,uVar5 & 0xfffffffb);\n    }\n    else {\n      local_1c = (uint *)(local_14 + 8);\n      do {\n        puVar10 = local_1c + 4;\n        if (*(char *)puVar10 != '\\0') {\n          uVar5 = *local_1c;\n          local_44 = uVar5 & 0x20;\n          local_50 = 0xffff0002;\n          local_4c = 0xd;\n          local_40 = 0x20;\n          local_54 = LVar2;\n          local_3c = puVar10;\n          local_28 = iVar9;\n          if ((uVar5 & 2) == 0) {\n            if ((uVar5 & 4) == 0) {\n              LVar4 = SendMessageA(local_8,0x1100,0,(LPARAM)&local_54);\n              *(LRESULT *)((int)DAT_00420d28 + iVar9 * 4) = LVar4;\n            }\n            else {\n              LVar2 = SendMessageA(local_8,0x110a,3,LVar2);\n            }\n          }\n          else {\n            local_4c = 0x4d;\n            local_2c = 1;\n            LVar2 = SendMessageA(local_8,0x1100,0,(LPARAM)&local_54);\n            local_20 = (HGLOBAL)0x1;\n            *(LRESULT *)((int)DAT_00420d28 + iVar9 * 4) = LVar2;\n            LVar2 = *(LRESULT *)((int)DAT_00420d28 + iVar9 * 4);\n          }\n        }\n        iVar9 = iVar9 + 1;\n        local_1c = local_1c + 0x106;\n      } while (iVar9 < DAT_0042476c);\n      if (local_20 == (HGLOBAL)0x0) goto LAB_00404da3;\n    }\n    if (local_10 == (HWND)0x0) {\n      ShowWindow(local_c,5);\n      FUN_004041a8((WPARAM)local_c);\n      goto LAB_0040515a;\n    }\n    FUN_004041a8((WPARAM)local_8);\n  }\n  if (param_2 == 0x405) {\n    param_3 = (HDC)0x0;\n    param_2 = 0x40f;\n    param_4 = (HWND)0x1;\n  }\n  if (((param_2 == 0x4e) || (param_2 == 0x413)) &&\n     ((local_10 = param_4, param_2 == 0x413 || (param_4[1].unused == 0x408)))) {\n    if (((DAT_0042473c & 0x200) == 0) &&\n       (((param_2 == 0x413 || (param_4[2].unused == -2)) &&\n        (iVar9 = FUN_00404ac6(local_8,(uint)(param_2 != 0x413)), -1 < iVar9)))) {\n      puVar10 = (uint *)(iVar9 * 0x418 + 8 + local_14);\n      uVar5 = *puVar10;\n      if ((uVar5 & 0x10) == 0) {\n        if ((uVar5 & 0x40) == 0) {\n          uVar5 = uVar5 ^ 1;\n        }\n        else {\n          uVar6 = uVar5 ^ 0x80;\n          if ((char)uVar6 < '\\0') {\n            uVar5 = uVar5 & 0xffffff00 | uVar6 & 0xff | 1;\n          }\n          else {\n            uVar5 = uVar5 & 0xffffff00 | uVar6 & 0xfe;\n          }\n        }\n        *puVar10 = uVar5;\n        FUN_0040117d(iVar9);\n        param_3 = (HDC)(iVar9 + 1);\n        param_4 = (HWND)(~DAT_0042473c >> 8 & 1);\n        param_2 = 0x40f;\n      }\n    }\n    if (local_10 != (HWND)0x0) {\n      if (local_10[2].unused == -0x192) {\n        SendMessageA(local_8,0x419,0,local_10[0x17].unused);\n      }\n      if (local_10[2].unused == -0x196) {\n        if (local_10[3].unused == 2) {\n          puVar10 = (uint *)(local_10[0x17].unused * 0x418 + 8 + local_14);\n          *puVar10 = *puVar10 | 0x20;\n        }\n        else {\n          puVar10 = (uint *)(local_10[0x17].unused * 0x418 + 8 + local_14);\n          *puVar10 = *puVar10 & 0xffffffdf;\n        }\n      }\n    }\n  }\n  if (param_2 == 0x111) {\n    if ((((short)param_3 != 0x3f9) || ((short)((uint)param_3 >> 0x10) != 1)) ||\n       (WVar3 = SendMessageA(local_c,0x147,0,0), WVar3 == 0xffffffff)) goto LAB_0040515a;\n    uVar5 = SendMessageA(local_c,0x150,WVar3,0);\n    if ((uVar5 == 0xffffffff) || (*(int *)(local_18 + uVar5 * 4) == 0)) {\n      uVar5 = 0x20;\n    }\n    FUN_00401299(uVar5);\n    SendMessageA(param_1,0x420,0,uVar5);\n    param_3 = (HDC)0xffffffff;\n    param_4 = (HWND)0x0;\n    param_2 = 0x40f;\n  }\n  if (param_2 == 0x200) {\n    SendMessageA(local_8,0x200,0,0);\n  }\n  if (param_2 == 0x40b) {\n    if (DAT_00420d14 != (HIMAGELIST)0x0) {\n      ImageList_Destroy(DAT_00420d14);\n    }\n    if (DAT_00420d28 != (HGLOBAL)0x0) {\n      GlobalFree(DAT_00420d28);\n    }\n    DAT_00420d14 = (HIMAGELIST)0x0;\n    DAT_00420d28 = (HGLOBAL)0x0;\n    _DAT_004247a0 = (HWND)0x0;\n  }\n  if (param_2 == 0x40f) {\n    FUN_004011ef(0,0);\n    if (param_3 != (HDC)0x0) {\n      pHVar7 = param_3;\n      if (param_3 != (HDC)0xffffffff) {\n        pHVar7 = (HDC)((int)&param_3[-1].unused + 3);\n      }\n      FUN_00404b46(8,pHVar7);\n    }\n    if (param_4 != (HWND)0x0) {\n      param_4 = (HWND)FUN_004012e2((int)DAT_00420d28);\n      FUN_00401299((uint)param_4);\n      iVar9 = 0;\n      WVar3 = 0;\n      if (0 < (int)param_4) {\n        do {\n          if (*(int *)(local_18 + iVar9 * 4) != 0) {\n            WVar3 = WVar3 + 1;\n          }\n          iVar9 = iVar9 + 1;\n        } while (iVar9 < (int)param_4);\n      }\n      SendMessageA(local_c,0x14e,WVar3,0);\n      param_2 = 0x420;\n    }\n    FUN_004011ef(0,0);\n    local_20 = DAT_00420d28;\n    local_3c = (uint *)0xf030;\n    local_14 = 0;\n    if (0 < DAT_0042476c) {\n      puVar10 = (uint *)(DAT_00424768 + 8);\n      do {\n        uVar5 = *(uint *)((int)local_20 + local_14 * 4);\n        if (uVar5 != 0) {\n          uVar6 = *puVar10;\n          local_48 = 8;\n          if ((uVar6 & 0x100) != 0) {\n            local_38 = puVar10 + 4;\n            local_48 = 9;\n            *(byte *)((int)puVar10 + 1) = *(byte *)((int)puVar10 + 1) & 0xfe;\n          }\n          if ((uVar6 & 0x40) == 0) {\n            iVar9 = (uVar6 & 1) + 1;\n            if ((uVar6 & 0x10) != 0) {\n              iVar9 = (uVar6 & 1) + 4;\n            }\n          }\n          else {\n            iVar9 = 3;\n          }\n          local_40 = (iVar9 << 0xb | uVar6 & 8) * 2 | uVar6 & 0x20;\n          local_44 = uVar5;\n          SendMessageA(local_8,0x1102,((int)uVar6 >> 5 & 1U) + 1,uVar5);\n          SendMessageA(local_8,0x110d,0,(LPARAM)&local_48);\n        }\n        local_14 = local_14 + 1;\n        puVar10 = puVar10 + 0x106;\n      } while (local_14 < DAT_0042476c);\n    }\n    InvalidateRect(local_8,(RECT *)0x0,1);\n    if (*(int *)(DAT_00423efc + 0x10) != 0) {\n      uVar5 = FUN_00404a99(5);\n      FUN_00404a81(0x3ff,-5,uVar5);\n    }\n  }\n  if ((param_2 == 0x420) && ((DAT_0042473c & 0x100) != 0)) {\n    iVar9 = (uint)(param_4 == (HWND)0x20) << 3;\n    ShowWindow(local_8,iVar9);\n    pHVar8 = GetDlgItem(param_1,0x3fe);\n    ShowWindow(pHVar8,iVar9);\n  }\nLAB_0040515a:\n  FUN_004041da(param_2,param_3,param_4);\n  return;\n}\n\n", "FUN_0040516f": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nLRESULT FUN_0040516f(HWND param_1,UINT param_2,WPARAM param_3,int param_4)\n\n{\n  BOOL BVar1;\n  LRESULT LVar2;\n  \n  if (param_2 == 0x102) {\n    if (param_3 == 0x20) {\n      FUN_004041bf(0x413);\n      return 0;\n    }\n  }\n  else {\n    if (param_2 == 0x200) {\n      BVar1 = IsWindowVisible(param_1);\n      if (BVar1 == 0) goto LAB_004051e1;\n      param_4 = FUN_00404ac6(param_1,1);\n      param_2 = 0x419;\n    }\n    if ((param_2 == 0x419) && (_DAT_00420d1c != param_4)) {\n      _DAT_00420d1c = param_4;\n      FUN_00404b46(6,param_4);\n    }\n  }\nLAB_004051e1:\n  LVar2 = CallWindowProcA(DAT_00420d24,param_1,param_2,param_3,param_4);\n  return LVar2;\n}\n\n", "FUN_004051fb": "\nvoid FUN_004051fb(int param_1,LPCSTR param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  LRESULT LVar3;\n  uint uVar4;\n  undefined4 local_34;\n  WPARAM local_30;\n  undefined4 local_2c;\n  undefined *local_20;\n  uint local_c;\n  HWND local_8;\n  \n  local_8 = DAT_00423f04;\n  if (DAT_00423f04 != (HWND)0x0) {\n    local_c = DAT_004247f4;\n    uVar4 = DAT_004247f4 & 1;\n    if (uVar4 == 0) {\n      FUN_004060f6(&DAT_00420510,param_1);\n    }\n    iVar1 = lstrlenA(&DAT_00420510);\n    if (param_2 != (LPCSTR)0x0) {\n      iVar2 = lstrlenA(param_2);\n      if (0x7ff < (uint)(iVar2 + iVar1)) {\n        return;\n      }\n      lstrcatA(&DAT_00420510,param_2);\n    }\n    if ((local_c & 4) == 0) {\n      SetWindowTextA(DAT_00423ee8,&DAT_00420510);\n    }\n    if ((local_c & 2) == 0) {\n      local_20 = &DAT_00420510;\n      local_34 = 1;\n      LVar3 = SendMessageA(local_8,0x1004,0,0);\n      local_30 = LVar3 - uVar4;\n      local_2c = 0;\n      SendMessageA(local_8,0x1007 - uVar4,0,(LPARAM)&local_34);\n      SendMessageA(local_8,0x1013,local_30,0);\n    }\n    if (uVar4 != 0) {\n      (&DAT_00420510)[iVar1] = 0;\n    }\n  }\n  return;\n}\n\n", "FUN_004052cd": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint FUN_004052cd(HWND param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  \n  iVar4 = DAT_0042476c;\n  iVar2 = DAT_00424768;\n  uVar1 = OleInitialize((LPVOID)0x0);\n  _DAT_004247f8 = _DAT_004247f8 | uVar1;\n  FUN_004041bf(0);\n  if (iVar4 != 0) {\n    piVar3 = (int *)(iVar2 + 0xc);\n    do {\n      iVar4 = iVar4 + -1;\n      if (((*(byte *)(piVar3 + -1) & 1) != 0) && (iVar2 = FUN_00401389(*piVar3,param_1), iVar2 != 0)\n         ) {\n        DAT_004247cc = DAT_004247cc + 1;\n        break;\n      }\n      piVar3 = piVar3 + 0x106;\n    } while (iVar4 != 0);\n  }\n  FUN_004041bf(0x404);\n  OleUninitialize();\n  return DAT_004247cc;\n}\n\n", "FUN_00405339": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nCOLORREF FUN_00405339(HWND param_1,DWORD param_2,HDC param_3,HWND param_4)\n\n{\n  DWORD DVar1;\n  HWND pHVar2;\n  HANDLE hObject;\n  HMENU hMenu;\n  LPCSTR lpNewItem;\n  int x;\n  BOOL BVar3;\n  LRESULT LVar4;\n  HGLOBAL hMem;\n  undefined *puVar5;\n  COLORREF CVar6;\n  int y;\n  WPARAM wParam;\n  SIZE_T dwBytes;\n  DWORD dwCreationFlags;\n  DWORD *lpThreadId;\n  undefined local_40 [8];\n  undefined4 local_38;\n  undefined4 local_34;\n  int local_30;\n  undefined *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 uStack28;\n  tagRECT local_18;\n  HWND local_8;\n  \n  DVar1 = param_2;\n  wParam = 0;\n  local_8 = DAT_00423f04;\n  if (param_2 == 0x110) {\n    local_30 = 0xffffffff;\n    local_24 = 0xffffffff;\n    local_38 = 2;\n    local_34 = 0;\n    local_2c = (undefined *)0x0;\n    local_28 = 0;\n    local_20 = 0;\n    uStack28 = 0;\n    param_3 = *(HDC *)(DAT_00424734 + 0x5c);\n    param_2 = *(DWORD *)(DAT_00424734 + 0x60);\n    DAT_00423ef0 = GetDlgItem(param_1,0x403);\n    DAT_00423ee8 = GetDlgItem(param_1,0x3ee);\n    DAT_00423f04 = GetDlgItem(param_1,0x3f8);\n    local_8 = DAT_00423f04;\n    FUN_004041a8((WPARAM)DAT_00423ef0);\n    DAT_00423ef4 = FUN_00404a99(4);\n    DAT_00423f0c = 0;\n    GetClientRect(local_8,&local_18);\n    local_30 = GetSystemMetrics(2);\n    local_30 = local_18.right - local_30;\n    SendMessageA(local_8,0x101b,0,(LPARAM)&local_38);\n    SendMessageA(local_8,0x1036,0x4000,0x4000);\n    if (-1 < (int)param_3) {\n      SendMessageA(local_8,0x1001,0,(LPARAM)param_3);\n      SendMessageA(local_8,0x1026,0,(LPARAM)param_3);\n    }\n    if (-1 < (int)param_2) {\n      SendMessageA(local_8,0x1024,0,param_2);\n    }\n    FUN_00404173(param_1,0x1b,param_4[0xc].unused);\n    if (((byte)DAT_0042473c & 3) != 0) {\n      ShowWindow(DAT_00423ef0,0);\n      if (((byte)DAT_0042473c & 2) == 0) {\n        ShowWindow(local_8,8);\n      }\n      else {\n        DAT_00423ef0 = (HWND)0x0;\n      }\n      FUN_004041a8((WPARAM)DAT_00423ee8);\n    }\n    pHVar2 = GetDlgItem(param_1,0x3ec);\n    SendMessageA(pHVar2,0x401,0,0x75300000);\n    if (((byte)DAT_0042473c & 4) != 0) {\n      SendMessageA(pHVar2,0x409,0,param_2);\n      SendMessageA(pHVar2,0x2001,0,(LPARAM)param_3);\n    }\nLAB_004056ba:\n    CVar6 = 0;\n  }\n  else {\n    if (param_2 == 0x405) {\n      lpThreadId = &param_2;\n      dwCreationFlags = 0;\n      pHVar2 = GetDlgItem(param_1,0x3ec);\n      hObject = CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_004052cd,pHVar2,dwCreationFlags,\n                             lpThreadId);\n      CloseHandle(hObject);\n    }\n    if (DVar1 == 0x111) {\n      if ((short)param_3 == 0x403) {\n        ShowWindow(DAT_00423ef0,0);\n        ShowWindow(local_8,8);\n        FUN_004041a8((WPARAM)local_8);\n        goto LAB_00405542;\n      }\n    }\n    else {\nLAB_00405542:\n      if (DVar1 == 0x404) {\n        if (_DAT_00423eec != 0) {\n          DAT_00420100 = 2;\n          FUN_0040414c(0x78);\n          goto LAB_00405563;\n        }\n        ShowWindow(DAT_00424728,8);\n        if (DAT_004247cc == 0) {\n          FUN_004051fb(*(int *)(DAT_00420508 + 0x34),(LPCSTR)0x0);\n        }\n        FUN_0040414c(1);\n      }\n      if ((DVar1 == 0x7b) && (param_3 == (HDC)local_8)) {\n        param_3 = (HDC)SendMessageA(local_8,0x1004,0,0);\n        if (0 < (int)param_3) {\n          hMenu = CreatePopupMenu();\n          lpNewItem = (LPCSTR)FUN_004060f6((byte *)0x0,-0x1f);\n          AppendMenuA(hMenu,0,1,lpNewItem);\n          x = (int)(short)param_4;\n          y = (int)(short)((uint)param_4 >> 0x10);\n          if (param_4 == (HWND)0xffffffff) {\n            GetWindowRect(local_8,&local_18);\n            x = local_18.left;\n            y = local_18.top;\n          }\n          BVar3 = TrackPopupMenu(hMenu,0x180,x,y,0,param_1,(RECT *)0x0);\n          if (BVar3 == 1) {\n            dwBytes = 1;\n            local_38 = 0;\n            local_2c = &DAT_00420d30;\n            local_28 = 0x1000;\n            param_1 = (HWND)param_3;\n            do {\n              param_1 = (HWND)((int)&param_1[-1].unused + 3);\n              LVar4 = SendMessageA(local_8,0x102d,(WPARAM)param_1,(LPARAM)local_40);\n              dwBytes = dwBytes + 2 + LVar4;\n            } while (param_1 != (HWND)0x0);\n            OpenClipboard((HWND)0x0);\n            EmptyClipboard();\n            hMem = GlobalAlloc(0x42,dwBytes);\n            puVar5 = (undefined *)GlobalLock(hMem);\n            do {\n              local_2c = puVar5;\n              LVar4 = SendMessageA(local_8,0x102d,wParam,(LPARAM)local_40);\n              puVar5 = puVar5 + LVar4;\n              *puVar5 = 0xd;\n              puVar5[1] = 10;\n              puVar5 = puVar5 + 2;\n              wParam = wParam + 1;\n            } while ((int)wParam < (int)param_3);\n            GlobalUnlock(hMem);\n            SetClipboardData(1,hMem);\n            CloseClipboard();\n          }\n        }\n        goto LAB_004056ba;\n      }\n    }\nLAB_00405563:\n    CVar6 = FUN_004041da(DVar1,param_3,param_4);\n  }\n  return CVar6;\n}\n\n", "FUN_004056c1": "\nDWORD FUN_004056c1(LPCSTR param_1)\n\n{\n  BOOL BVar1;\n  DWORD DVar2;\n  undefined local_24;\n  undefined local_23;\n  undefined2 local_22;\n  undefined *local_20;\n  undefined *local_1c;\n  undefined4 local_18;\n  undefined *local_14;\n  _SECURITY_ATTRIBUTES local_10;\n  \n  local_23 = 0;\n  local_20 = &DAT_00408374;\n  local_1c = &DAT_00408374;\n  local_10.lpSecurityDescriptor = &local_24;\n  local_18 = 0;\n  local_10.bInheritHandle = 0;\n  local_24 = 1;\n  local_22 = 4;\n  local_14 = &DAT_00408364;\n  local_10.nLength = 0xc;\n  BVar1 = CreateDirectoryA(param_1,&local_10);\n  if (BVar1 == 0) {\n    DVar2 = GetLastError();\n    if (DVar2 != 0xb7) {\n      return DVar2;\n    }\n    BVar1 = SetFileSecurityA(param_1,0x80000007,&local_24);\n    if (BVar1 == 0) {\n      DVar2 = GetLastError();\n      return DVar2;\n    }\n  }\n  return 0;\n}\n\n", "FUN_0040573e": "\nDWORD FUN_0040573e(LPCSTR param_1)\n\n{\n  BOOL BVar1;\n  DWORD DVar2;\n  \n  BVar1 = CreateDirectoryA(param_1,(LPSECURITY_ATTRIBUTES)0x0);\n  if (BVar1 == 0) {\n    DVar2 = GetLastError();\n  }\n  else {\n    DVar2 = 0;\n  }\n  return DVar2;\n}\n\n", "FUN_0040575b": "\nundefined4 FUN_0040575b(void)\n\n{\n  FARPROC pFVar1;\n  int iVar2;\n  \n  pFVar1 = FUN_0040646c(5);\n  if (pFVar1 != (FARPROC)0x0) {\n    iVar2 = (*pFVar1)();\n    if (iVar2 != 0) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\n", "FUN_00405773": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nHANDLE FUN_00405773(LPSTR param_1)\n\n{\n  HANDLE pvVar1;\n  _PROCESS_INFORMATION local_14;\n  \n  _DAT_00422538 = 0x44;\n  pvVar1 = (HANDLE)CreateProcessA((LPCSTR)0x0,param_1,(LPSECURITY_ATTRIBUTES)0x0,\n                                  (LPSECURITY_ATTRIBUTES)0x0,0,0x4000000,(LPVOID)0x0,(LPCSTR)0x0,\n                                  (LPSTARTUPINFOA)&DAT_00422538,&local_14);\n  if (pvVar1 != (HANDLE)0x0) {\n    CloseHandle(local_14.hThread);\n    pvVar1 = local_14.hProcess;\n  }\n  return pvVar1;\n}\n\n", "FUN_004057b6": "\nvoid FUN_004057b6(SHELLEXECUTEINFOA *param_1)\n\n{\n  param_1->lpIDList = (void *)0x0;\n  param_1->cbSize = 0x3c;\n  ShellExecuteExA(param_1);\n  return;\n}\n\n", "SetDlgItemTextA": "\nBOOL SetDlgItemTextA(HWND hDlg,int nIDDlgItem,LPCSTR lpString)\n\n{\n  BOOL BVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x004057ce. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  BVar1 = SetDlgItemTextA(hDlg,nIDDlgItem,lpString);\n  return BVar1;\n}\n\n", "FUN_004057d4": "\nvoid FUN_004057d4(int param_1,LPSTR param_2)\n\n{\n  GetDlgItemTextA(DAT_00423ef8,param_1,param_2,0x400);\n  return;\n}\n\n", "FUN_004057f0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_004057f0(undefined4 param_1,uint param_2)\n\n{\n  uint uVar1;\n  \n  uVar1 = param_2 & 0x1fffff;\n  if ((_DAT_004247e0 == 0) || (param_2 >> 0x15 == 0)) {\n    if (_DAT_004247e8 != 0) {\n      uVar1 = uVar1 ^ 0x180000;\n    }\n    _DAT_0040a234 = DAT_00424728;\n    _DAT_0040a238 = DAT_00424720;\n    _DAT_0040a23c = param_1;\n    _DAT_0040a240 = &DAT_00423f20;\n    _DAT_0040a244 = uVar1;\n    MessageBoxIndirectA((MSGBOXPARAMSA *)&DAT_0040a230);\n  }\n  return;\n}\n\n", "FUN_00405854": "\nundefined4 FUN_00405854(LPCSTR param_1,byte param_2)\n\n{\n  DWORD dwFileAttributes;\n  int iVar1;\n  \n  dwFileAttributes = FUN_00405c48(param_1);\n  if (dwFileAttributes != 0xffffffff) {\n    if ((param_2 & 1) == 0) {\n      iVar1 = DeleteFileA(param_1);\n    }\n    else {\n      iVar1 = RemoveDirectoryA(param_1);\n    }\n    if (iVar1 != 0) {\n      return 1;\n    }\n    if ((param_2 & 4) == 0) {\n      SetFileAttributesA(param_1,dwFileAttributes);\n    }\n  }\n  return 0;\n}\n\n", "FUN_0040589c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0040589c(LPCSTR param_1,uint param_2)\n\n{\n  uint uVar1;\n  bool bVar2;\n  undefined3 extraout_var;\n  BOOL BVar3;\n  int iVar4;\n  char *pcVar5;\n  int iVar6;\n  undefined *puVar7;\n  CHAR *pCVar8;\n  byte local_150;\n  CHAR local_124;\n  char acStack291 [275];\n  int local_10;\n  HANDLE local_c;\n  uint local_8;\n  \n  local_8 = param_2 & 4;\n  bVar2 = FUN_00405b5a(param_1);\n  local_10 = CONCAT31(extraout_var,bVar2);\n  if ((param_2 & 8) == 0) {\n    uVar1 = param_2 & 1;\n    if ((uVar1 == 0) || ((local_10 != 0 && ((param_2 & 2) != 0)))) {\n      FUN_004060d4(&DAT_00421d38,param_1);\n      if (uVar1 == 0) {\n        FUN_00405ab3(param_1);\n      }\n      else {\n        lstrcatA(&DAT_00421d38,&DAT_0040a3c4);\n      }\n      if ((*param_1 != '\\0') || (DAT_00421d38 == '\\\\')) {\n        lstrcatA(param_1,&DAT_0040a014);\n      }\n      iVar4 = lstrlenA(param_1);\n      local_c = FindFirstFileA(&DAT_00421d38,(LPWIN32_FIND_DATAA)&local_150);\n      if (local_c != (HANDLE)0xffffffff) {\n        do {\n          pCVar8 = &local_124;\n          pcVar5 = (char *)FUN_00405a97(&local_124,'?');\n          if ((*pcVar5 != '\\0') && (acStack291[259] != '\\0')) {\n            pCVar8 = &local_124 + 0x104;\n          }\n          if ((*pCVar8 != '.') ||\n             ((pCVar8[1] != '\\0' && ((pCVar8[1] != '.' || (pCVar8[2] != '\\0')))))) {\n            FUN_004060d4(param_1 + iVar4,pCVar8);\n            if ((local_150 & 0x10) == 0) {\n              iVar6 = FUN_00405854(param_1,(byte)local_8);\n              if (iVar6 == 0) {\n                if (local_8 == 0) {\n                  _DAT_004247c8 = _DAT_004247c8 + 1;\n                }\n                else {\n                  FUN_004051fb(-0xf,param_1);\n                  FUN_00405eb3(param_1,(LPCSTR)0x0);\n                }\n              }\n              else {\n                FUN_004051fb(-0xe,param_1);\n              }\n            }\n            else if (((byte)param_2 & 3) == 3) {\n              FUN_0040589c(param_1,param_2);\n            }\n          }\n          BVar3 = FindNextFileA(local_c,(LPWIN32_FIND_DATAA)&local_150);\n        } while (BVar3 != 0);\n        FindClose(local_c);\n      }\n      if (uVar1 != 0) {\n        (param_1 + iVar4)[-1] = '\\0';\n      }\n    }\n    if (uVar1 != 0) {\n      if (local_10 != 0) {\n        puVar7 = FUN_004063d7(param_1);\n        if (puVar7 == (undefined *)0x0) {\n          return;\n        }\n        FUN_00405a6c(param_1);\n        iVar4 = FUN_00405854(param_1,(byte)local_8 | 1);\n        if (iVar4 != 0) {\n          FUN_004051fb(-0x1b,param_1);\n          return;\n        }\n        if (local_8 != 0) {\n          FUN_004051fb(-0xf,param_1);\n          FUN_00405eb3(param_1,(LPCSTR)0x0);\n          return;\n        }\n      }\n      _DAT_004247c8 = _DAT_004247c8 + 1;\n    }\n  }\n  else {\n    BVar3 = DeleteFileA(param_1);\n    _DAT_004247c8 = _DAT_004247c8 + (uint)(BVar3 == 0);\n  }\n  return;\n}\n\n", "FUN_00405a6c": "\nLPCSTR FUN_00405a6c(LPCSTR param_1)\n\n{\n  int iVar1;\n  LPSTR pCVar2;\n  \n  iVar1 = lstrlenA(param_1);\n  pCVar2 = CharPrevA(param_1,param_1 + iVar1);\n  if (*pCVar2 != '\\\\') {\n    lstrcatA(param_1,&DAT_0040a014);\n  }\n  return param_1;\n}\n\n", "FUN_00405a97": "\nvoid FUN_00405a97(LPCSTR param_1,char param_2)\n\n{\n  for (; (*param_1 != '\\0' && (*param_1 != param_2)); param_1 = CharNextA(param_1)) {\n  }\n  return;\n}\n\n", "FUN_00405ab3": "\nLPCSTR FUN_00405ab3(LPCSTR param_1)\n\n{\n  int iVar1;\n  LPCSTR lpszCurrent;\n  \n  iVar1 = lstrlenA(param_1);\n  lpszCurrent = param_1 + iVar1;\n  do {\n    if (*lpszCurrent == '\\\\') break;\n    lpszCurrent = CharPrevA(param_1,lpszCurrent);\n  } while (param_1 < lpszCurrent);\n  *lpszCurrent = '\\0';\n  return lpszCurrent + 1;\n}\n\n", "FUN_00405ad9": "\nundefined4 FUN_00405ad9(byte *param_1)\n\n{\n  byte bVar1;\n  undefined4 uVar2;\n  \n  bVar1 = *param_1 | 0x20;\n  if (((*param_1 == 0x5c) && (param_1[1] == 0x5c)) ||\n     (('`' < (char)bVar1 && (((char)bVar1 < '{' && (param_1[1] == 0x3a)))))) {\n    uVar2 = 1;\n  }\n  else {\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n", "FUN_00405b05": "\nchar * FUN_00405b05(LPCSTR param_1)\n\n{\n  LPSTR lpsz;\n  char *pcVar1;\n  int iVar2;\n  \n  lpsz = CharNextA(param_1);\n  pcVar1 = CharNextA(lpsz);\n  if (((*param_1 == '\\0') || (*lpsz != ':')) || (lpsz[1] != '\\\\')) {\n    if ((*param_1 == '\\\\') && (param_1[1] == '\\\\')) {\n      iVar2 = 2;\n      do {\n        iVar2 = iVar2 + -1;\n        pcVar1 = (char *)FUN_00405a97(pcVar1,'\\\\');\n        if (*pcVar1 == '\\0') goto LAB_00405b52;\n        pcVar1 = pcVar1 + 1;\n      } while (iVar2 != 0);\n    }\n    else {\nLAB_00405b52:\n      pcVar1 = (char *)0x0;\n    }\n  }\n  else {\n    pcVar1 = CharNextA(pcVar1);\n  }\n  return pcVar1;\n}\n\n", "FUN_00405b5a": "\nbool FUN_00405b5a(LPCSTR param_1)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  int iVar3;\n  DWORD DVar4;\n  \n  FUN_004060d4(&DAT_00422138,param_1);\n  pbVar1 = (byte *)FUN_00405b05(&DAT_00422138);\n  if ((pbVar1 != (byte *)0x0) &&\n     ((FUN_0040633e(pbVar1), ((byte)DAT_0042473c & 0x80) == 0 ||\n      ((*pbVar1 != 0 && (*pbVar1 != 0x5c)))))) {\n    while( true ) {\n      iVar3 = lstrlenA(&DAT_00422138);\n      if (iVar3 <= (int)(pbVar1 + -0x422138)) {\n        FUN_00405a6c(&DAT_00422138);\n        DVar4 = GetFileAttributesA(&DAT_00422138);\n        return DVar4 != 0xffffffff;\n      }\n      pbVar2 = FUN_004063d7(&DAT_00422138);\n      if ((pbVar2 != (byte *)0x0) && ((*pbVar2 & 0x10) == 0)) break;\n      FUN_00405ab3(&DAT_00422138);\n    }\n  }\n  return false;\n}\n\n", "FUN_00405bd2": "\nLPCSTR FUN_00405bd2(LPSTR param_1,LPCSTR param_2)\n\n{\n  CHAR CVar1;\n  int iVar2;\n  int iVar3;\n  \n  iVar2 = lstrlenA(param_2);\n  while( true ) {\n    iVar3 = lstrlenA(param_1);\n    if (iVar3 < iVar2) {\n      return (LPCSTR)0x0;\n    }\n    CVar1 = param_1[iVar2];\n    param_1[iVar2] = '\\0';\n    iVar3 = lstrcmpiA(param_1,param_2);\n    param_1[iVar2] = CVar1;\n    if (iVar3 == 0) break;\n    param_1 = CharNextA(param_1);\n  }\n  return param_1;\n}\n\n", "FUN_00405c28": "\nvoid FUN_00405c28(undefined *param_1,int param_2,int param_3)\n\n{\n  int iVar1;\n  \n  if (param_3 != 0) {\n    iVar1 = param_2 - (int)param_1;\n    do {\n      *param_1 = param_1[iVar1];\n      param_1 = param_1 + 1;\n      param_3 = param_3 + -1;\n    } while (param_3 != 0);\n  }\n  return;\n}\n\n", "FUN_00405c48": "\nDWORD FUN_00405c48(LPCSTR param_1)\n\n{\n  DWORD DVar1;\n  \n  DVar1 = GetFileAttributesA(param_1);\n  if (DVar1 != 0xffffffff) {\n    SetFileAttributesA(param_1,DVar1 & 0xfffffffe);\n  }\n  return DVar1;\n}\n\n", "FUN_00405c6d": "\nvoid FUN_00405c6d(LPCSTR param_1,DWORD param_2,DWORD param_3)\n\n{\n  DWORD DVar1;\n  \n  DVar1 = GetFileAttributesA(param_1);\n  CreateFileA(param_1,param_2,1,(LPSECURITY_ATTRIBUTES)0x0,param_3,\n              -(uint)(DVar1 != 0xffffffff) & DVar1,(HANDLE)0x0);\n  return;\n}\n\n", "FUN_00405c9c": "\nLPSTR FUN_00405c9c(LPSTR param_1,LPCSTR param_2)\n\n{\n  LPSTR lpTempFileName;\n  DWORD DVar1;\n  UINT UVar2;\n  int iVar3;\n  \n  lpTempFileName = param_1;\n  iVar3 = 100;\n  do {\n    iVar3 = iVar3 + -1;\n    param_1 = DAT_0040a3cc;\n    DVar1 = GetTickCount();\n    param_1._0_3_ = CONCAT12(param_1._2_1_ + (char)(DVar1 % 0x1a),param_1._0_2_);\n    param_1 = (LPSTR)((uint)param_1 & 0xff000000 | (uint)(uint3)param_1);\n    UVar2 = GetTempFileNameA(param_2,(LPCSTR)&param_1,0,lpTempFileName);\n    if (UVar2 != 0) {\n      return lpTempFileName;\n    }\n  } while (iVar3 != 0);\n  *lpTempFileName = '\\0';\n  return (LPSTR)0x0;\n}\n\n", "FUN_00405ce5": "\nundefined4 FUN_00405ce5(HANDLE param_1,LPVOID param_2,DWORD param_3)\n\n{\n  DWORD DVar1;\n  BOOL BVar2;\n  undefined4 uVar3;\n  \n  DVar1 = param_3;\n  BVar2 = ReadFile(param_1,param_2,param_3,&param_3,(LPOVERLAPPED)0x0);\n  if ((BVar2 == 0) || (DVar1 != param_3)) {\n    uVar3 = 0;\n  }\n  else {\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n", "FUN_00405d14": "\nundefined4 FUN_00405d14(HANDLE param_1,LPCVOID param_2,DWORD param_3)\n\n{\n  DWORD DVar1;\n  BOOL BVar2;\n  undefined4 uVar3;\n  \n  DVar1 = param_3;\n  BVar2 = WriteFile(param_1,param_2,param_3,&param_3,(LPOVERLAPPED)0x0);\n  if ((BVar2 == 0) || (DVar1 != param_3)) {\n    uVar3 = 0;\n  }\n  else {\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n", "FUN_00405d43": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid __cdecl FUN_00405d43(LPCSTR param_1,LPCSTR param_2)\n\n{\n  HANDLE pvVar1;\n  DWORD DVar2;\n  int iVar3;\n  LPCSTR pCVar4;\n  LPSTR hMem;\n  int iVar5;\n  LPCSTR pCVar6;\n  LPCSTR pCVar7;\n  CHAR *pCVar8;\n  LPSTR pCVar9;\n  \n  _DAT_00422ac0 = 0x4c554e;\n  if (param_2 != (LPCSTR)0x0) {\n    pvVar1 = (HANDLE)FUN_00405c6d(param_2,0,1);\n    CloseHandle(pvVar1);\n    DVar2 = GetShortPathNameA(param_2,&DAT_00422ac0,0x400);\n    if (DVar2 == 0) {\n      return;\n    }\n    if (0x400 < (int)DVar2) {\n      return;\n    }\n  }\n  DVar2 = GetShortPathNameA(param_1,&DAT_00422ec0,0x400);\n  if ((DVar2 != 0) && ((int)DVar2 < 0x401)) {\n    iVar3 = wsprintfA(&DAT_004226c0,s__s__s_0040a3e0,&DAT_00422ac0,&DAT_00422ec0);\n    FUN_004060f6(&DAT_00422ec0,*(int *)(DAT_00424734 + 0x128));\n    pvVar1 = (HANDLE)FUN_00405c6d(&DAT_00422ec0,0xc0000000,4);\n    if (pvVar1 != (HANDLE)0xffffffff) {\n      pCVar4 = (LPCSTR)GetFileSize(pvVar1,(LPDWORD)0x0);\n      hMem = (LPSTR)GlobalAlloc(0x40,(SIZE_T)(pCVar4 + iVar3 + 10));\n      if ((hMem != (LPSTR)0x0) && (iVar5 = FUN_00405ce5(pvVar1,hMem,(DWORD)pCVar4), iVar5 != 0)) {\n        pCVar6 = FUN_00405bd2(hMem,s__Rename__0040a3d4);\n        if (pCVar6 == (LPCSTR)0x0) {\n          lstrcpyA(hMem + (int)pCVar4,s__Rename__0040a3d4);\n          pCVar4 = pCVar4 + 10;\n          pCVar6 = pCVar4;\n        }\n        else {\n          pCVar7 = FUN_00405bd2(pCVar6 + 10,&DAT_0040a3d0);\n          pCVar6 = pCVar4;\n          if (pCVar7 != (LPCSTR)0x0) {\n            pCVar9 = hMem + (int)pCVar4;\n            pCVar8 = pCVar9 + iVar3;\n            for (; pCVar7 < pCVar9; pCVar9 = pCVar9 + -1) {\n              *pCVar8 = *pCVar9;\n              pCVar8 = pCVar8 + -1;\n            }\n            pCVar6 = pCVar7 + (1 - (int)hMem);\n          }\n        }\n        FUN_00405c28(hMem + (int)pCVar6,(int)&DAT_004226c0,iVar3);\n        SetFilePointer(pvVar1,0,(PLONG)0x0,0);\n        FUN_00405d14(pvVar1,hMem,(DWORD)(pCVar4 + iVar3));\n        GlobalFree(hMem);\n      }\n      CloseHandle(pvVar1);\n    }\n  }\n  return;\n}\n\n", "FUN_00405eb3": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00405eb3(LPCSTR param_1,LPCSTR param_2)\n\n{\n  BOOL BVar1;\n  \n  BVar1 = MoveFileExA(param_1,param_2,5);\n  if (BVar1 == 0) {\n    FUN_00405d43(param_1,param_2);\n  }\n  _DAT_004247d0 = _DAT_004247d0 + 1;\n  return;\n}\n\n", "FUN_00405edf": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nuint FUN_00405edf(uint param_1,uint *param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  uVar1 = *param_2;\n  uVar3 = ~DAT_0042472c >> 0x16 & 0x100;\n  if (((uVar1 & 0x20) == 0) || ((param_1 & 0x60000000) == 0)) {\n    if ((uVar1 & 0x100000) != 0) {\n      uVar1 = uVar1 | _DAT_004247f0;\n    }\n  }\n  else {\n    uVar2 = param_1 >> 0x15 & 0x300;\n    if (uVar2 == 0x300) {\n      uVar2 = ~uVar3 & _DAT_004247f0;\n    }\n    uVar1 = (uVar1 & 0xfffffeff | uVar2) & 0xfffffdff;\n    param_1 = param_1 & 0x9fffffff;\n  }\n  *param_2 = uVar1 & 0xffefffdf;\n  return ~-(uint)((uVar1 & uVar3) != 0) & param_1;\n}\n\n", "FUN_00405f5a": "\nLSTATUS FUN_00405f5a(uint param_1,LPCSTR param_2,REGSAM param_3,PHKEY param_4)\n\n{\n  HKEY hKey;\n  LSTATUS LVar1;\n  \n  hKey = (HKEY)FUN_00405edf(param_1,&param_3);\n  if (hKey == (HKEY)0x0) {\n    LVar1 = 6;\n  }\n  else {\n    LVar1 = RegOpenKeyExA(hKey,param_2,0,param_3,param_4);\n  }\n  return LVar1;\n}\n\n", "FUN_00405f88": "\nLSTATUS FUN_00405f88(uint param_1,LPCSTR param_2,REGSAM param_3,PHKEY param_4)\n\n{\n  HKEY hKey;\n  LSTATUS LVar1;\n  \n  hKey = (HKEY)FUN_00405edf(param_1,&param_3);\n  if (hKey == (HKEY)0x0) {\n    LVar1 = 6;\n  }\n  else {\n    LVar1 = RegCreateKeyExA(hKey,param_2,0,(LPSTR)0x0,0,param_3,(LPSECURITY_ATTRIBUTES)0x0,param_4,\n                            (LPDWORD)0x0);\n  }\n  return LVar1;\n}\n\n", "FUN_00405fbb": "\nvoid FUN_00405fbb(uint param_1,LPCSTR param_2,LPCSTR param_3,LPBYTE param_4,HKEY param_5)\n\n{\n  LPBYTE pBVar1;\n  LSTATUS LVar2;\n  DWORD local_8;\n  \n  local_8 = 0x400;\n  LVar2 = FUN_00405f5a(param_1,param_2,-(uint)(param_5 != (HKEY)0x0) & 0x100 | 0x20019,&param_5);\n  pBVar1 = param_4;\n  if (LVar2 == 0) {\n    LVar2 = RegQueryValueExA(param_5,param_3,(LPDWORD)0x0,(LPDWORD)&param_2,param_4,&local_8);\n    RegCloseKey(param_5);\n    pBVar1[0x3ff] = '\\0';\n    if (LVar2 == 0) {\n      if (param_2 == (LPCSTR)0x1) {\n        return;\n      }\n      if (param_2 == (LPCSTR)0x2) {\n        return;\n      }\n    }\n  }\n  *pBVar1 = '\\0';\n  return;\n}\n\n", "FUN_00406032": "\nvoid FUN_00406032(LPSTR param_1,undefined4 param_2)\n\n{\n  wsprintfA(param_1,\"%d\",param_2);\n  return;\n}\n\n", "FUN_0040604b": "\nint FUN_0040604b(byte *param_1)\n\n{\n  byte bVar1;\n  char cVar2;\n  byte *pbVar3;\n  uint uVar4;\n  int iVar5;\n  char cVar6;\n  int iVar7;\n  int local_8;\n  \n  iVar7 = 0;\n  local_8 = 1;\n  cVar2 = '\\n';\n  cVar6 = '9';\n  if (*param_1 == 0x2d) {\n    param_1 = param_1 + 1;\n    local_8 = -1;\n  }\n  pbVar3 = param_1;\n  if (*param_1 == 0x30) {\n    pbVar3 = param_1 + 1;\n    bVar1 = *pbVar3;\n    if (('/' < (char)bVar1) && ((char)bVar1 < '8')) {\n      cVar2 = '\\b';\n      cVar6 = '7';\n    }\n    if ((bVar1 & 0xdf) == 0x58) {\n      cVar2 = '\\x10';\n      pbVar3 = param_1 + 2;\n    }\n  }\n  do {\n    uVar4 = (uint)(char)*pbVar3;\n    pbVar3 = pbVar3 + 1;\n    if (((int)uVar4 < 0x30) || ((int)cVar6 < (int)uVar4)) {\n      if ((cVar2 != '\\x10') ||\n         (((int)(uVar4 & 0xffffffdf) < 0x41 || (0x46 < (int)(uVar4 & 0xffffffdf))))) {\n        return local_8 * iVar7;\n      }\n      iVar5 = (uVar4 & 7) + 9;\n    }\n    else {\n      iVar5 = uVar4 - 0x30;\n    }\n    iVar7 = cVar2 * iVar7 + iVar5;\n  } while( true );\n}\n\n", "FUN_004060d4": "\nvoid FUN_004060d4(LPSTR param_1,LPCSTR param_2)\n\n{\n  lstrcpynA(param_1,param_2,0x400);\n  return;\n}\n\n", "lstrlenA": "\nint lstrlenA(LPCSTR lpString)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x004060ea. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = lstrlenA(lpString);\n  return iVar1;\n}\n\n", "lstrcatA": "\nLPSTR lstrcatA(LPSTR lpString1,LPCSTR lpString2)\n\n{\n  LPSTR pCVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x004060f0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pCVar1 = lstrcatA(lpString1,lpString2);\n  return pCVar1;\n}\n\n", "FUN_004060f6": "\nvoid FUN_004060f6(byte *param_1,int param_2)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte bVar3;\n  bool bVar4;\n  int iVar5;\n  HRESULT HVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  uint uVar9;\n  int iVar10;\n  byte *lpBuffer;\n  uint local_1c [4];\n  BOOL local_c;\n  LPCITEMIDLIST local_8;\n  \n  pbVar7 = param_1;\n  if (param_2 < 0) {\n    param_2 = *(int *)(DAT_00423efc - (param_2 * 4 + 4));\n  }\n  pbVar8 = (byte *)(param_2 + DAT_00424778);\n  lpBuffer = &DAT_004236c0;\n  if (((byte *)0x4236bf < param_1) && (param_1 + -0x4236c0 < (byte *)0x800)) {\n    param_1 = (byte *)0x0;\n    lpBuffer = pbVar7;\n  }\n  do {\n    while( true ) {\n      bVar1 = *pbVar8;\n      if ((bVar1 == 0) || (0x3ff < (int)(lpBuffer + -0x4236c0))) {\n        *lpBuffer = 0;\n        if (param_1 != (byte *)0x0) {\n          FUN_004060d4((LPSTR)param_1,&DAT_004236c0);\n        }\n        return;\n      }\n      pbVar7 = pbVar8 + 1;\n      if (bVar1 < 4) break;\n      if (bVar1 == 4) {\n        *lpBuffer = *pbVar7;\n        lpBuffer = lpBuffer + 1;\n        pbVar8 = pbVar8 + 2;\n      }\n      else {\n        *lpBuffer = bVar1;\n        lpBuffer = lpBuffer + 1;\n        pbVar8 = pbVar7;\n      }\n    }\n    bVar2 = pbVar8[2];\n    local_1c[3] = (uint)(char)bVar2;\n    bVar3 = *pbVar7;\n    local_1c[1] = (uint)(char)bVar3;\n    uVar9 = (local_1c[3] & 0x7f) << 7 | local_1c[1] & 0x7f;\n    local_1c[0] = CONCAT22((undefined2)((char)bVar3 >> 7),(short)(char)bVar3) | 0x8000;\n    local_1c[2] = CONCAT22((undefined2)((char)bVar2 >> 7),(short)(char)bVar2) | 0x8000;\n    if (bVar1 == 2) {\n      iVar10 = 2;\n      if ((((DAT_0042472c < 0) && ((short)DAT_0042472c != 0x5a04)) && (local_1c[3] != 0x23)) &&\n         (local_1c[3] != 0x2e)) {\n        bVar4 = false;\n      }\n      else {\n        bVar4 = true;\n      }\n      if (DAT_004247c4 != 0) {\n        iVar10 = 4;\n      }\n      if ((char)bVar3 < '\\0') {\n        FUN_00405fbb(0x80000002,\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\",\n                     (LPCSTR)((local_1c[1] & 0x3f) + DAT_00424778),lpBuffer,\n                     (HKEY)(local_1c[1] & 0x40));\n        if (*lpBuffer == 0) {\n          FUN_004060f6(lpBuffer,local_1c[3]);\n          goto LAB_0040629d;\n        }\nLAB_004062a2:\n        if (local_1c[3] == 0x1a) {\n          lstrcatA((LPSTR)lpBuffer,\"\\\\Microsoft\\\\Internet Explorer\\\\Quick Launch\");\n        }\n      }\n      else {\n        if (local_1c[1] == 0x25) {\n          GetSystemDirectoryA((LPSTR)lpBuffer,0x400);\n        }\n        else {\n          if (local_1c[1] == 0x24) {\n            GetWindowsDirectoryA((LPSTR)lpBuffer,0x400);\n            iVar10 = 0;\n          }\n          while ((iVar10 != 0 &&\n                 (((iVar10 = iVar10 + -1, DAT_00424724 == (code *)0x0 || (!bVar4)) ||\n                  (iVar5 = (*DAT_00424724)(DAT_00424728,local_1c[iVar10],0,0,lpBuffer), iVar5 != 0))\n                 ))) {\n            HVar6 = SHGetSpecialFolderLocation(DAT_00424728,local_1c[iVar10],&local_8);\n            if (HVar6 == 0) {\n              local_c = SHGetPathFromIDListA(local_8,(LPSTR)lpBuffer);\n              CoTaskMemFree(local_8);\n              if (local_c != 0) break;\n            }\n            *lpBuffer = 0;\n          }\n        }\nLAB_0040629d:\n        if (*lpBuffer != 0) goto LAB_004062a2;\n      }\nLAB_004062b3:\n      FUN_0040633e(lpBuffer);\n    }\n    else if (bVar1 == 3) {\n      if (uVar9 == 0x1d) {\n        FUN_00406032((LPSTR)lpBuffer,DAT_00424728);\n      }\n      else {\n        FUN_004060d4((LPSTR)lpBuffer,&DAT_00425000 + uVar9 * 0x400);\n      }\n      if (uVar9 - 0x15 < 7) goto LAB_004062b3;\n    }\n    else if (bVar1 == 1) {\n      FUN_004060f6(lpBuffer,-1 - uVar9);\n    }\n    iVar10 = lstrlenA((LPCSTR)lpBuffer);\n    lpBuffer = lpBuffer + iVar10;\n    pbVar8 = pbVar8 + 3;\n  } while( true );\n}\n\n", "FUN_0040633e": "\nvoid FUN_0040633e(byte *param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  char *pcVar3;\n  LPSTR pCVar4;\n  byte *lpsz;\n  byte *lpsz_00;\n  \n  if ((((*param_1 == 0x5c) && (param_1[1] == 0x5c)) && (param_1[2] == 0x3f)) && (param_1[3] == 0x5c)\n     ) {\n    param_1 = param_1 + 4;\n  }\n  if ((*param_1 != 0) && (iVar2 = FUN_00405ad9(param_1), iVar2 != 0)) {\n    param_1 = param_1 + 2;\n  }\n  bVar1 = *param_1;\n  lpsz_00 = param_1;\n  lpsz = param_1;\n  while (bVar1 != 0) {\n    if ((0x1f < bVar1) &&\n       (pcVar3 = (char *)FUN_00405a97(s__________0040a3e8,bVar1), *pcVar3 == '\\0')) {\n      pCVar4 = CharNextA((LPCSTR)lpsz_00);\n      FUN_00405c28(lpsz,(int)lpsz_00,(int)pCVar4 - (int)lpsz_00);\n      lpsz = (byte *)CharNextA((LPCSTR)lpsz);\n    }\n    lpsz_00 = (byte *)CharNextA((LPCSTR)lpsz_00);\n    bVar1 = *lpsz_00;\n  }\n  *lpsz = 0;\n  while( true ) {\n    lpsz = (byte *)CharPrevA((LPCSTR)param_1,(LPCSTR)lpsz);\n    if ((*lpsz != 0x20) && (*lpsz != 0x5c)) break;\n    *lpsz = 0;\n    if (lpsz <= param_1) {\n      return;\n    }\n  }\n  return;\n}\n\n", "FUN_004063d7": "\nundefined * FUN_004063d7(LPCSTR param_1)\n\n{\n  HANDLE hFindFile;\n  undefined *puVar1;\n  \n  hFindFile = FindFirstFileA(param_1,(LPWIN32_FIND_DATAA)&DAT_00422580);\n  if (hFindFile == (HANDLE)0xffffffff) {\n    puVar1 = (undefined *)0x0;\n  }\n  else {\n    FindClose(hFindFile);\n    puVar1 = &DAT_00422580;\n  }\n  return puVar1;\n}\n\n", "FUN_004063fe": "\nvoid FUN_004063fe(undefined4 param_1)\n\n{\n  UINT UVar1;\n  int iVar2;\n  CHAR local_124 [288];\n  \n  UVar1 = GetSystemDirectoryA(local_124,0x104);\n  if (0x104 < UVar1) {\n    UVar1 = 0;\n  }\n  if ((UVar1 == 0) || (local_124[UVar1 - 1] == '\\\\')) {\n    iVar2 = 1;\n  }\n  else {\n    iVar2 = 0;\n  }\n  wsprintfA(local_124 + UVar1,s__s_s_dll_0040a3f4,&DAT_0040a014 + iVar2,param_1);\n  LoadLibraryExA(local_124,(HANDLE)0x0,8);\n  return;\n}\n\n", "FUN_0040646c": "\nFARPROC FUN_0040646c(int param_1)\n\n{\n  LPCSTR lpModuleName;\n  HMODULE hModule;\n  FARPROC pFVar1;\n  \n  lpModuleName = (&PTR_s_KERNEL32_0040a258)[param_1 * 2];\n  hModule = GetModuleHandleA(lpModuleName);\n  if ((hModule == (HMODULE)0x0) &&\n     (hModule = (HMODULE)FUN_004063fe(lpModuleName), hModule == (HMODULE)0x0)) {\n    return (FARPROC)0x0;\n  }\n  pFVar1 = GetProcAddress(hModule,(&PTR_s_SetDefaultDllDirectories_0040a25c)[param_1 * 2]);\n  return pFVar1;\n}\n\n", "FUN_004064a8": "\nvoid FUN_004064a8(UINT param_1)\n\n{\n  BOOL BVar1;\n  MSG local_20;\n  \n  while( true ) {\n    BVar1 = PeekMessageA(&local_20,(HWND)0x0,param_1,param_1,1);\n    if (BVar1 == 0) break;\n    DispatchMessageA(&local_20);\n  }\n  return;\n}\n\n", "GetProcAddress": "\nFARPROC GetProcAddress(HMODULE hModule,LPCSTR lpProcName)\n\n{\n  FARPROC pFVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x004064db. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pFVar1 = GetProcAddress(hModule,lpProcName);\n  return pFVar1;\n}\n\n", "FUN_004064e1": "\nDWORD FUN_004064e1(HANDLE param_1)\n\n{\n  DWORD DVar1;\n  DWORD local_8;\n  \n  DVar1 = WaitForSingleObject(param_1,100);\n  while (DVar1 == 0x102) {\n    FUN_004064a8(0xf);\n    DVar1 = WaitForSingleObject(param_1,100);\n  }\n  GetExitCodeProcess(param_1,&local_8);\n  return local_8;\n}\n\n", "FUN_00406523": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nuint FUN_00406523(uint param_1,byte *param_2,int param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  \n  if (_DAT_004232c4 == 0) {\n    uVar2 = 0;\n    do {\n      iVar3 = 8;\n      uVar1 = uVar2;\n      do {\n        uVar1 = uVar1 >> 1 ^ -(uint)((uVar1 & 1) != 0) & 0xedb88320;\n        iVar3 = iVar3 + -1;\n      } while (iVar3 != 0);\n      (&DAT_004232c0)[uVar2] = uVar1;\n      uVar2 = uVar2 + 1;\n    } while ((int)uVar2 < 0x100);\n  }\n  uVar2 = ~param_1;\n  if (param_3 != 0) {\n    do {\n      uVar2 = uVar2 >> 8 ^ (&DAT_004232c0)[uVar2 & 0xff ^ (uint)*param_2];\n      param_2 = param_2 + 1;\n      param_3 = param_3 + -1;\n    } while (param_3 != 0);\n  }\n  return ~uVar2;\n}\n\n", "FUN_00406591": "\nvoid __fastcall FUN_00406591(int param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = 0x80;\n  do {\n    iVar1 = iVar1 + -1;\n    *(undefined *)(iVar1 + param_1) = 0;\n  } while (iVar1 != 0);\n  *(undefined4 *)(param_1 + 0x78) = 0xffffffff;\n  *(undefined4 *)(param_1 + 0x68) = 1;\n  *(undefined4 *)(param_1 + 100) = 1;\n  *(undefined4 *)(param_1 + 0x60) = 1;\n  *(undefined4 *)(param_1 + 0x5c) = 1;\n  return;\n}\n\n", "FUN_004065b1": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nundefined4 __fastcall FUN_004065b1(uint *param_1)\n\n{\n  byte bVar1;\n  ushort uVar2;\n  SIZE_T dwBytes;\n  byte *pbVar3;\n  byte *pbVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  ushort *puVar10;\n  uint *puVar11;\n  uint *puVar12;\n  bool bVar13;\n  uint local_8c [4];\n  SIZE_T local_7c;\n  uint local_78;\n  byte *local_74;\n  int local_70;\n  byte *local_6c;\n  int local_68;\n  uint local_64;\n  byte local_60;\n  byte local_5f;\n  ushort *local_5c;\n  ushort *local_58;\n  int local_54;\n  uint local_50;\n  uint local_4c;\n  uint local_48;\n  uint local_44;\n  uint local_40;\n  int local_3c;\n  int local_38;\n  int local_34;\n  uint local_30;\n  uint local_2c;\n  uint local_28;\n  uint local_24;\n  uint local_20;\n  uint local_1c;\n  uint local_18;\n  uint local_14;\n  uint local_10;\n  HGLOBAL local_c;\n  HGLOBAL local_8;\n  \n  puVar11 = param_1;\n  puVar12 = local_8c;\n  for (iVar8 = 0x22; iVar8 != 0; iVar8 = iVar8 + -1) {\n    *puVar12 = *puVar11;\n    puVar11 = puVar11 + 1;\n    puVar12 = puVar12 + 1;\n  }\n  uVar9 = local_48;\n  puVar10 = local_58;\n  if (local_34 == -1) {\n    return 1;\n  }\nLAB_004065e4:\n  do {\n    uVar5 = local_24;\n    uVar7 = local_30;\n    pbVar4 = local_6c;\n    pbVar3 = local_74;\n    switch(local_8c[0]) {\n    case 0:\n      if (local_70 == 0) goto LAB_00406fe6;\n      local_70 = local_70 + -1;\n      local_74 = local_74 + 1;\n      bVar1 = *pbVar3;\n      if (0xe1 < bVar1) {\n        return 0xffffffff;\n      }\n      local_40 = ((uint)bVar1 % 0x2d) % 9;\n      local_20 = (1 << bVar1 / 0x2d) - 1;\n      local_1c = (1 << (sbyte)((ulonglong)((uint)bVar1 % 0x2d) / 9)) - 1;\n      iVar8 = (0x300 << (char)local_40 + bVar1 / 0x2d) + 0x736;\n      dwBytes = iVar8 * 2;\n      if (dwBytes != local_7c) {\n        if (local_8 != (HGLOBAL)0x0) {\n          GlobalFree(local_8);\n        }\n        local_8 = GlobalAlloc(0x40,dwBytes);\n        if (local_8 == (HGLOBAL)0x0) {\n          return 0xffffffff;\n        }\n        local_7c = dwBytes;\n      }\n      while (iVar8 != 0) {\n        iVar8 = iVar8 + -1;\n        *(undefined2 *)((int)local_8 + iVar8 * 2) = 0x400;\n      }\n      local_44 = 0;\n      for (local_4c = 0; (int)local_4c < 4; local_4c = local_4c + 1) {\nswitchD_004065f3_caseD_1:\n        if (local_70 == 0) {\n          local_8c[0] = 1;\n          goto LAB_00406fe6;\n        }\n        local_70 = local_70 + -1;\n        local_44 = local_44 | (uint)*local_74 << ((byte)(local_4c << 3) & 0x1f);\n        local_74 = local_74 + 1;\n      }\n      if (local_44 != local_78) {\n        local_78 = local_44;\n        if (local_c != (HGLOBAL)0x0) {\n          GlobalFree(local_c);\n        }\n        local_c = GlobalAlloc(0x40,local_44);\n        if (local_c == (HGLOBAL)0x0) {\n          return 0xffffffff;\n        }\n      }\n      local_4c = 5;\n      *(undefined *)((int)local_c + (local_78 - 1)) = 0;\n      while (uVar7 = local_4c, local_4c = local_4c - 1, uVar7 != 0) {\nswitchD_004065f3_caseD_3:\n        if (local_70 == 0) {\n          local_8c[0] = 3;\n          goto LAB_00406fe6;\n        }\n        local_70 = local_70 + -1;\n        bVar1 = *local_74;\n        local_74 = local_74 + 1;\n        local_10 = local_10 << 8 | (uint)bVar1;\n      }\n    case 2:\n      local_8c[1] = 6;\n      local_50 = local_64 & local_20;\n      puVar10 = (ushort *)((int)local_8 + (local_3c * 0x10 + (local_64 & local_20)) * 2);\n      break;\n    case 1:\n      goto switchD_004065f3_caseD_1;\n    case 3:\n      goto switchD_004065f3_caseD_3;\n    case 4:\n      goto switchD_004065f3_caseD_4;\n    case 5:\n      goto switchD_004065f3_caseD_5;\n    case 6:\n      if (local_44 != 0) {\n        local_38 = 1;\n        local_8c[1] = 7;\n        puVar10 = (ushort *)((int)local_8 + local_3c * 2 + 0x180);\n        break;\n      }\n      local_5c = (ushort *)\n                 (((uint)(local_60 >> (8 - (byte)local_40 & 0x1f)) +\n                  ((local_64 & local_1c) << ((byte)local_40 & 0x1f))) * 0x600 + 0xe6c + (int)local_8\n                 );\n      if (local_3c < 4) {\n        local_3c = 0;\n      }\n      else if (local_3c < 10) {\n        local_3c = local_3c + -3;\n      }\n      else {\n        local_3c = local_3c + -6;\n      }\n      if (local_38 != 0) {\n        uVar7 = local_18 - local_30;\n        if (local_78 <= uVar7) {\n          uVar7 = uVar7 + local_78;\n        }\n        uVar9 = 1;\n        local_5f = *(byte *)(uVar7 + (int)local_c);\n        do {\n          bVar1 = local_5f;\n          local_5f = local_5f << 1;\n          local_4c = (uint)(bVar1 >> 7);\n          puVar10 = local_5c + ((bVar1 >> 7) + 1) * 0x100 + uVar9;\n          uVar2 = *puVar10;\n          local_58 = puVar10;\n          uVar7 = (local_14 >> 0xb) * (uint)uVar2;\n          bVar13 = uVar7 <= local_10;\n          if (bVar13) {\n            local_14 = local_14 - uVar7;\n            local_10 = local_10 - uVar7;\n            local_44 = 1;\n            uVar9 = uVar9 * 2 + 1;\n            *puVar10 = uVar2 - (uVar2 >> 5);\n          }\n          else {\n            local_44 = 0;\n            local_14 = uVar7;\n            uVar9 = uVar9 * 2;\n            *puVar10 = (short)((int)(0x800 - (uint)uVar2) >> 5) + uVar2;\n          }\n          local_44 = (uint)bVar13;\n          local_48 = uVar9;\n          if (local_14 < 0x1000000) {\nswitchD_004065f3_caseD_d:\n            if (local_70 == 0) {\n              local_8c[0] = 0xd;\n              goto LAB_00406fe6;\n            }\n            local_14 = local_14 << 8;\n            bVar1 = *local_74;\n            local_70 = local_70 + -1;\n            local_74 = local_74 + 1;\n            local_10 = local_10 << 8 | (uint)bVar1;\n          }\n          if (local_4c != local_44) goto LAB_004068d7;\n        } while ((int)uVar9 < 0x100);\n        goto LAB_0040693b;\n      }\n      uVar9 = 1;\n      do {\n        puVar10 = local_5c + uVar9;\n        uVar2 = *puVar10;\n        local_58 = puVar10;\n        uVar7 = (local_14 >> 0xb) * (uint)uVar2;\n        if (local_10 < uVar7) {\n          local_14 = uVar7;\n          uVar9 = uVar9 * 2;\n          *puVar10 = (short)((int)(0x800 - (uint)uVar2) >> 5) + uVar2;\n        }\n        else {\n          local_14 = local_14 - uVar7;\n          local_10 = local_10 - uVar7;\n          uVar9 = uVar9 * 2 + 1;\n          *puVar10 = uVar2 - (uVar2 >> 5);\n        }\n        local_48 = uVar9;\n        if (local_14 < 0x1000000) {\nswitchD_004065f3_caseD_f:\n          if (local_70 == 0) {\n            local_8c[0] = 0xf;\n            goto LAB_00406fe6;\n          }\n          local_14 = local_14 << 8;\n          bVar1 = *local_74;\n          local_70 = local_70 + -1;\n          local_74 = local_74 + 1;\n          local_10 = local_10 << 8 | (uint)bVar1;\n        }\n      } while ((int)uVar9 < 0x100);\n      goto LAB_0040693f;\n    case 7:\n      if (local_44 != 1) {\n        local_8c[2] = 0x16;\n        local_24 = local_28;\n        local_28 = local_2c;\n        local_2c = local_30;\n        local_3c = ((6 < local_3c) - 1 & 0xfffffffd) + 10;\n        local_5c = (ushort *)((int)local_8 + 0x664);\n        goto switchD_004065f3_caseD_11;\n      }\n      local_8c[1] = 8;\n      puVar10 = (ushort *)((int)local_8 + local_3c * 2 + 0x198);\n      break;\n    case 8:\n      if (local_44 == 0) {\n        local_8c[1] = 9;\n        puVar10 = (ushort *)((int)local_8 + ((local_3c + 0xf) * 0x10 + local_50) * 2);\n      }\n      else {\n        local_8c[1] = 10;\n        puVar10 = (ushort *)((int)local_8 + local_3c * 2 + 0x1b0);\n      }\n      break;\n    case 9:\n      if (local_44 != 0) goto LAB_00406b67;\n      if (local_64 == 0) {\n        return 0xffffffff;\n      }\n      local_3c = (uint)(6 < local_3c) * 2 + 9;\n    case 0x1b:\n      if (local_68 == 0) {\n        local_8c[0] = 0x1b;\n        goto LAB_00406fe6;\n      }\n      uVar7 = local_18 - local_30;\n      if (local_78 <= uVar7) {\n        uVar7 = uVar7 + local_78;\n      }\n      local_60 = *(byte *)(uVar7 + (int)local_c);\n      *(byte *)(local_18 + (int)local_c) = local_60;\n      local_64 = local_64 + 1;\n      local_6c = local_6c + 1;\n      local_68 = local_68 + -1;\n      *pbVar4 = local_60;\n      goto LAB_00406b0b;\n    case 10:\n      if (local_44 == 0) goto LAB_00406b5e;\n      local_8c[1] = 0xb;\n      puVar10 = (ushort *)((int)local_8 + local_3c * 2 + 0x1c8);\n      break;\n    case 0xb:\n      uVar6 = local_28;\n      if (local_44 != 0) {\n        local_24 = local_28;\n        uVar6 = uVar5;\n      }\n      local_28 = local_2c;\n      local_2c = uVar6;\nLAB_00406b5e:\n      local_30 = local_2c;\n      local_2c = uVar7;\nLAB_00406b67:\n      local_8c[2] = 0x15;\n      local_5c = (ushort *)((int)local_8 + 0xa68);\n    case 0x11:\nswitchD_004065f3_caseD_11:\n      local_8c[1] = 0x12;\n      puVar10 = local_5c;\n      break;\n    case 0xc:\n      while (local_70 != 0) {\n        local_14 = local_14 << 8;\n        bVar1 = *local_74;\n        local_70 = local_70 + -1;\n        local_74 = local_74 + 1;\n        local_10 = local_10 << 8 | (uint)bVar1;\n        uVar7 = local_30;\n        do {\n          local_4c = local_4c - 1;\nLAB_00406c2f:\n          if ((int)local_4c < 1) {\n            local_44 = 4;\n            local_30 = uVar7 + uVar9 * 0x10;\n            local_5c = (ushort *)((int)local_8 + 0x644);\n            goto LAB_00406c73;\n          }\n          uVar9 = uVar9 * 2;\n          local_14 = local_14 >> 1;\n          local_48 = uVar9;\n          if (local_14 <= local_10) {\n            local_10 = local_10 - local_14;\n            uVar9 = uVar9 | 1;\n            local_48 = uVar9;\n          }\n        } while (0xffffff < local_14);\n      }\n      local_8c[0] = 0xc;\n      goto LAB_00406fe6;\n    case 0xd:\n      goto switchD_004065f3_caseD_d;\n    case 0xe:\n      goto switchD_004065f3_caseD_e;\n    case 0xf:\n      goto switchD_004065f3_caseD_f;\n    case 0x10:\n      goto switchD_004065f3_caseD_10;\n    case 0x12:\n      if (local_44 == 0) {\n        local_34 = 0;\n        iVar8 = local_50 * 8 + 2;\nLAB_00406dad:\n        local_5c = local_5c + iVar8;\n        local_44 = 3;\n        goto LAB_00406e8a;\n      }\n      local_8c[1] = 0x13;\n      puVar10 = local_5c + 1;\n      break;\n    case 0x13:\n      if (local_44 == 0) {\n        local_34 = 8;\n        iVar8 = local_50 * 8 + 0x82;\n        goto LAB_00406dad;\n      }\n      local_5c = local_5c + 0x102;\n      local_34 = 0x10;\n      local_44 = 8;\nLAB_00406e8a:\n      local_8c[3] = 0x14;\n    case 0x17:\nswitchD_004065f3_caseD_17:\n      local_54 = 1;\n      for (local_4c = local_44; 0 < (int)local_4c; local_4c = local_4c - 1) {\n        puVar10 = local_5c + local_54;\n        local_58 = puVar10;\n        uVar2 = *puVar10;\n        uVar9 = (local_14 >> 0xb) * (uint)uVar2;\n        if (local_10 < uVar9) {\n          local_14 = uVar9;\n          local_54 = local_54 << 1;\n          *puVar10 = (short)((int)(0x800 - (uint)uVar2) >> 5) + uVar2;\n        }\n        else {\n          local_14 = local_14 - uVar9;\n          local_10 = local_10 - uVar9;\n          *puVar10 = uVar2 - (uVar2 >> 5);\n          local_54 = local_54 * 2 + 1;\n        }\n        if (local_14 < 0x1000000) {\nswitchD_004065f3_caseD_18:\n          if (local_70 == 0) {\n            local_8c[0] = 0x18;\n            goto LAB_00406fe6;\n          }\n          local_14 = local_14 << 8;\n          bVar1 = *local_74;\n          local_70 = local_70 + -1;\n          local_74 = local_74 + 1;\n          local_10 = local_10 << 8 | (uint)bVar1;\n        }\n      }\n      uVar9 = local_54 - (1 << ((byte)local_44 & 0x1f));\n      local_48 = uVar9;\n      local_8c[0] = local_8c[3];\n      goto LAB_00406e48;\n    case 0x14:\n      local_34 = local_34 + uVar9;\n      local_8c[0] = local_8c[2];\n      goto LAB_00406e48;\n    case 0x15:\n      local_3c = ((6 < local_3c) - 1 & 0xfffffffd) + 0xb;\n      goto LAB_00406d2f;\n    case 0x16:\n      iVar8 = local_34;\n      if (3 < local_34) {\n        iVar8 = 3;\n      }\n      local_44 = 6;\n      local_8c[3] = 0x19;\n      local_5c = (ushort *)(iVar8 * 0x80 + 0x360 + (int)local_8);\n      goto switchD_004065f3_caseD_17;\n    case 0x18:\n      goto switchD_004065f3_caseD_18;\n    case 0x19:\n      local_30 = uVar9;\n      if (3 < (int)uVar9) {\n        iVar8 = (int)uVar9 >> 1;\n        local_44 = iVar8 - 1;\n        uVar7 = (uint)((byte)uVar9 & 1 | 2) << ((byte)local_44 & 0x1f);\n        local_30 = uVar7;\n        if (0xd < (int)uVar9) {\n          uVar9 = 0;\n          local_4c = iVar8 - 5;\n          goto LAB_00406c2f;\n        }\n        local_5c = (ushort *)((int)local_8 + (uVar7 - uVar9) * 2 + 0x55e);\nLAB_00406c73:\n        uVar9 = 0;\n        local_54 = 1;\n        local_48 = 0;\n        for (local_4c = 0; (int)local_4c < (int)local_44; local_4c = local_4c + 1) {\n          puVar10 = local_5c + local_54;\n          local_58 = puVar10;\n          uVar2 = *puVar10;\n          uVar7 = (local_14 >> 0xb) * (uint)uVar2;\n          if (local_10 < uVar7) {\n            local_14 = uVar7;\n            local_54 = local_54 << 1;\n            *puVar10 = (short)((int)(0x800 - (uint)uVar2) >> 5) + uVar2;\n          }\n          else {\n            local_14 = local_14 - uVar7;\n            local_10 = local_10 - uVar7;\n            uVar9 = local_48 | 1 << ((byte)local_4c & 0x1f);\n            local_48 = uVar9;\n            *puVar10 = uVar2 - (uVar2 >> 5);\n            local_54 = local_54 * 2 + 1;\n          }\n          if (local_14 < 0x1000000) {\nswitchD_004065f3_caseD_10:\n            if (local_70 == 0) {\n              local_8c[0] = 0x10;\n              goto LAB_00406fe6;\n            }\n            local_14 = local_14 << 8;\n            bVar1 = *local_74;\n            local_70 = local_70 + -1;\n            local_74 = local_74 + 1;\n            local_10 = local_10 << 8 | (uint)bVar1;\n          }\n        }\n        local_30 = local_30 + uVar9;\n      }\n      local_30 = local_30 + 1;\nLAB_00406d2f:\n      if (local_30 == 0) {\n        local_34 = 0xffffffff;\n        goto LAB_00406fe6;\n      }\n      if (local_64 < local_30) {\n        return 0xffffffff;\n      }\n      local_34 = local_34 + 2;\n      local_64 = local_64 + local_34;\nswitchD_004065f3_caseD_1c:\n      do {\n        pbVar3 = local_6c;\n        if (local_68 == 0) {\n          local_8c[0] = 0x1c;\n          goto LAB_00406fe6;\n        }\n        uVar7 = local_18 - local_30;\n        if (local_78 <= uVar7) {\n          uVar7 = uVar7 + local_78;\n        }\n        local_60 = *(byte *)(uVar7 + (int)local_c);\n        *(byte *)(local_18 + (int)local_c) = local_60;\n        local_6c = local_6c + 1;\n        local_68 = local_68 + -1;\n        local_34 = local_34 + -1;\n        *pbVar3 = local_60;\n        local_18 = (local_18 + 1) % local_78;\n      } while (0 < local_34);\n      goto LAB_00406b0e;\n    case 0x1a:\n      goto switchD_004065f3_caseD_1a;\n    case 0x1c:\n      goto switchD_004065f3_caseD_1c;\n    default:\n      return 0xffffffff;\n    }\n    local_58 = puVar10;\nswitchD_004065f3_caseD_4:\n    uVar2 = *puVar10;\n    uVar7 = (local_14 >> 0xb) * (uint)uVar2;\n    bVar13 = uVar7 <= local_10;\n    if (bVar13) {\n      local_14 = local_14 - uVar7;\n      local_10 = local_10 - uVar7;\n      local_44 = 1;\n      *puVar10 = uVar2 - (uVar2 >> 5);\n    }\n    else {\n      local_14 = uVar7;\n      local_44 = 0;\n      *puVar10 = (short)((int)(0x800 - (uint)uVar2) >> 5) + uVar2;\n    }\n    local_44 = (uint)bVar13;\n    local_8c[0] = local_8c[1];\n    if (local_14 < 0x1000000) {\nswitchD_004065f3_caseD_5:\n      if (local_70 == 0) {\n        local_8c[0] = 5;\n        goto LAB_00406fe6;\n      }\n      local_14 = local_14 << 8;\n      bVar1 = *local_74;\n      local_70 = local_70 + -1;\n      local_74 = local_74 + 1;\n      local_10 = local_10 << 8 | (uint)bVar1;\n      local_8c[0] = local_8c[1];\n    }\nLAB_00406e48:\n  } while( true );\nLAB_004068d7:\n  if ((int)uVar9 < 0x100) {\n    puVar10 = local_5c + uVar9;\n    uVar2 = *puVar10;\n    local_58 = puVar10;\n    uVar7 = (local_14 >> 0xb) * (uint)uVar2;\n    if (local_10 < uVar7) {\n      local_14 = uVar7;\n      uVar9 = uVar9 * 2;\n      *puVar10 = (short)((int)(0x800 - (uint)uVar2) >> 5) + uVar2;\n    }\n    else {\n      local_14 = local_14 - uVar7;\n      local_10 = local_10 - uVar7;\n      uVar9 = uVar9 * 2 + 1;\n      *puVar10 = uVar2 - (uVar2 >> 5);\n    }\n    local_48 = uVar9;\n    if (local_14 < 0x1000000) {\nswitchD_004065f3_caseD_e:\n      if (local_70 == 0) {\n        local_8c[0] = 0xe;\n        goto LAB_00406fe6;\n      }\n      local_14 = local_14 << 8;\n      bVar1 = *local_74;\n      local_70 = local_70 + -1;\n      local_74 = local_74 + 1;\n      local_10 = local_10 << 8 | (uint)bVar1;\n    }\n    goto LAB_004068d7;\n  }\nLAB_0040693b:\n  local_38 = 0;\nLAB_0040693f:\n  local_60 = (byte)local_48;\nswitchD_004065f3_caseD_1a:\n  if (local_68 == 0) {\n    local_8c[0] = 0x1a;\nLAB_00406fe6:\n    puVar11 = local_8c;\n    for (iVar8 = 0x22; iVar8 != 0; iVar8 = iVar8 + -1) {\n      *param_1 = *puVar11;\n      puVar11 = puVar11 + 1;\n      param_1 = param_1 + 1;\n    }\n    return 0;\n  }\n  local_64 = local_64 + 1;\n  local_6c = local_6c + 1;\n  local_68 = local_68 + -1;\n  *pbVar4 = local_60;\n  *(byte *)(local_18 + (int)local_c) = local_60;\nLAB_00406b0b:\n  local_18 = (local_18 + 1) % local_78;\nLAB_00406b0e:\n  local_8c[0] = 2;\n  goto LAB_004065e4;\n}\n\n"}
